# Spring Advanced 정리



# 02 ThreadLocal

### 동시성 문제

- 인스턴스의 필드(주로 싱글톤)나 static 같은 공용 필드 접근시 많이발생

해결

- `ThreadLocal` 을 통해 쓰레드 값을 동기화하기 위해 파라미터를 전달한다. 

<br />

### WAS 에서 ThreadLocal 문제

- WAS 는 쓰레드를 새로 만드는 대신, 쓰레드 풀에 반납하여 다시 재사용한다. 해당 쓰레드풀의 전용 보관소에 저장되어있던 데이터를 다른 사용자가 조회하는 심각한 문제 발생

해결

- 요청이 끝날 때는 쓰레드로컬 저장소의 데이터를 제거해야 한다. `ThreadLocal.remover()`

<br />

# 03 템플릿 메소드 패턴, 전략 패턴, 콜백 패턴

## 1 템플릿 메소드 패턴

템플릿 메소드 패턴은 **다형성**을 이용해서 변하는 부분과 변하지 않는 부분을 분리하는 패턴이다.

→ 상속과 오버라이딩을 통한 다형성으로 중복코드가 발생하는 문제를 해결하는 것이다.

추상클래스가 템플릿이 되고, 이를 상속하는 하위 클래스에서 비즈니스 로직을 변경한다.

### 상속의 문제

- 상속의 단점을 그대로 가져간다.
  - 자식 클래스가 부모 클래스와 강하게 결합하므로, (높은 결합도, 의존관계 문제) 부모클래스가 바뀌면 자식이 영향을 많이 받는다.
  - 부모 클래스를 전혀 사용하지 않는데 부모 클래스를 알아야 한다.
  - 별도 클래스나 익명 클래스를 만들어야 한다.

해결

- 상속의 단점을 해결할 수 있는 디자인 패턴 → 전략 패턴 (Stragegy Pattern) 사용
  - 상속보다는 합성(Composition)



> 좋은 설계란)
>
> SRP, 단일 책임의 원칙 : 변경 지점을 하나로 모아 변경에 쉽게 대처할 수 있는 구조를 만드는 것

<br />

## 2 전략 패턴

변하지 않는 부분을 `Context` (템플릿 역할), 변하는 부분을 `Strategy 인터페이스`에 만들고, 이 인터페이스를 구현한다.

- 상속이 아니라 위임(delegation)으로 문제 해결
- Strategy 의 구현체를 변경하거나 새로 만들어도 Context 에는 전혀 영향을 주지 않는다. (변경하지 않아도 된다.)
- 스프링에서 의존 관계 주입시 사용하는 패턴이 전략 패턴이다.

필드 주입

- 정석
- 선 조립, 후 실행

파라미터 전달

- 필드 주입에 비해 전략을 더욱 유연하게 변경할 수 있다.
- 단점은 실행할 때마다 전략을 계속 지정해주어야 한다.

<br />

## 3 템플릿 콜백 패턴

다른 코드의 인수로 넘겨주는 실행 가능한 코드를 콜백(callback) 이라고 한다.

템플릿 콜백 패턴은 전략 패턴에서 파라미터 전달로 콜백이 들어오는 구조다. 스프링에서 자주 사용되므로 스프링에서만 이렇게 부른다.

<br />

### 한계

- 템플릿 메소드 패턴, 전략 패턴, 템플릿 콜백 패턴은 모두 원본 코드를 수정해야 한다는 단점이 있다.
- 극복하기 위해 `'프록시 패턴'` 사용

<br />

---

# 04 프록시 패턴, 데코레이터 패턴

클라이언트가 서버에게 프록시(대리자)를 통해 간접적으로 요청하는 패턴

프록시 장점

1. 접근 제어
   - 권한에 따른 접근 차단
   - 캐싱
   - **지연 로딩** 
2. 부가기능 추가
   - 요청 값이나 응답 값을 중간에 변형한다.
   - 실행 시간을 남기거나, 로그를 남긴다.
3. 프록시 체인
4. 대체 가능
   - 클라이언트가 사용하는 서버 객체를 프록시 객체로 변경해도 클라이언트는 코드를 변경하지 않고 동작할 수 있어야 한다.

> 런타임 객체 의존 관계
>
> - 런타임에 클라이언트 객체를 DI 를 사용해서 Client → Server 에서 Client → Proxy 로 객체 의존관계를 변경해도 클라이언트 코드를 전혀 변경하지 않아도 된다. 클라이언트에서는 변경된 사실 조차 모른다.
> - DI 를 사용하면 클라이언트 코드 변경 없이 유연하게 프록시를 주입할 수 있다.

> 프록시 패턴 : 접근제어가 목적
>
> 데코레이터 패턴 : 부가기능 추가가 목적

<br />

<br />

# 동적 프록시

## JDK 동적프록시
- `InvocationHandler` 인터페이스를 구현하여 핸들러를 만든다. (여기 공통 부가기능을 담는다.)
- 인보케이션핸들러와 프록시의 부모 인터페이스를 통해 프록시를 만든다.
- 이 때 핸들러는 타겟(실제 구현체)을 의존한다. (Object target)
- 클라이언트는 실제 구현체 대신에 프록시를 주입받아 프록시를 호출한다.


## CGLib
- Code Generator Library
- 클래스를 상속받아서 프록시 클래스르 만들 수 있다.
- `MethodInterceptor` 를 구현하여 부가기능을 담는다. 
- `Enhancer` 에 메소드 인터셉터와, 프록시의 부모클래스를 set 하여 프록시를 만든다.

## 스프링이 지원하는 프록시 (ProxyFactory)
- `MethodInterceptor` 를 구현하여 Advice 를 만든다. (Advice는 부가로직이다. CGLib 의 `MethodInterceptor` 와 이름이 같다.)
- `ProxyFactory` 에 타겟클래스와 어드바이스를 담아서 프록시팩토리를 만든다.
- 받은 타겟클래스 정보 기반으로 인터페이스를 가진다면 JDK 동적 프록시기반, 인터페이스가 없고 구체클래스만 있다면 CGLib 기반 프록시를 만든다.

### Advisor
어드바이저 = 어드바이스 + 포인트컷

## 빈 후처리기 (BeanPostProcessor)
- 빈후처리기는 빈을 조작하고 변경할 수 있는 후킹 포인트이다.
- 스프링 AOP 는 빈후처리기에서 포인트컷을 사용해서 프록시 대상 여부를 확인한다.

### 자동 프록시 생성기 (AutoProxyCreator)
- 정확히는 AnnotationAwareAspectJAutoProxyCreator
- Advisor 를 만들고 스프링 빈으로 등록하면, 자동으로 프록시를 등록해준다.
```shell
1. 생성 : 스프링 빈 대상이 되는 객체를 생성한다.
2. 전달 : 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.
3. 모든 어드바이저 빈 조회 : 빈 후처리기는 스프링 컨테이너에서 모든 Advisor 를 조회한다.
	- @Aspect 어드바이저 빌더 내부에 저장된 Advisor 도 모두 조회한다.
4. 프록시 적용 대상 체크 : Advisor 에 포함되어있는 Pointcut 정보를 바탕으로 프록시를 적용할 지 판단한다. 모든 객체의 클래스정보와 메소드를 포인트컷에 하나하나 비교해본다.
5. 프록시 생성 : 프록시 생성대상이면 프록시를 생성하고 빈으로 등록한다. 아니라면 원본 객체를 그대로 반환하여 빈으로 등록한다.
```

## @AspectJ AOP
- `@AspectJ` : 어노테이션 기반 프록시를 적용할 때 필요하다.
- `@Around` : 포인트컷 표현식을 넣는다. 어드바이스 메소드 위에 붙인다.
- `ProceedingJoinPoint` : 실제 호출 대상, 전달 인자 그리고 객체와 메소드의 호출 정보가 담겨있다. 어드바이스에서 살펴본 `MethodInvocation invocation` 과 유사하다. 
- 자동프록시생성기는 `@AspectJ` 가 붙은 클래스를 찾아서 이를 Advisor 로 만들어준다. 또한 이 어드바이저를 기반으로 프록시를 생성한다.

AOP는 프록시 패턴을 통해, 횡단 관심사(cross-cutting concerns) 문제를 하나의 공통 어드바이저에 담는다. 그리고 원하는 장소(포인트컷)에 이를 적용할 수 있다.


## JDK, CGLib 각각의 한계와 스프링의 해결책
<br />

- JDK 동적 프록시 단점
	- 프록시를 타겟 클래스로 타입캐스팅 할 수 없다.
	- 타겟 클래스를 의존 관계 주입할 수 없다. (인터페이스를 주입해야 한다. 원래 구조상 그러는게 올바르다.)
- CGLib 단점 
	- 생성자를 2번 호출해야 한다. (타겟 클래스 생성시점, 프록시 생성 시점에 부모클래스 생성자 호출)
	- final 키워드가 클래스에 있으면 상속이 불가하고, final 메소드에 있으면 오버라이딩이 불가하여 프록시를 생성할 수 없다.

- 스프링의 해결책
	- 스프링 3.2 부터 CGLib 를 스프링 내부에 함께 패키징 했다.
	- 스프링 4.0 부터 `objenesis` 라이브러리를 통해 생성자는 1번만 호출하게 된다.
	- 스프링부트 2.0 부터 CGLib 를 기본으로 사용하도록 했다.


