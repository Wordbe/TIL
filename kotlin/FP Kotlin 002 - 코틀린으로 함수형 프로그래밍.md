# FP Kotlin 002 - 코틀린으로 함수형 프로그래밍

# 1 프로퍼티 선언과 안전한 널 처리

- 읽기 전용
- 가변 프로퍼티

# 2 함수와 람다

- 자바에서 void 는 원시형 타입이지만, 코틀린에서 Unit 은 참조형 타입이다.

```kotlin
public object Unit {
  override fun toString() = "kotlin.Unit"
}
```

- object 는 싱글턴 객체
- 따라서 반환타입이 Unit 인 함수는 실제로 싱글턴 객체를 반환한다.
- Unit 을 반환 타입으로 사용하는 경우 일반적으로 생략한다.

## 매개변수에 기본값 설정

## 익명함수와 람다 표현식

- anonymous function : 함수 이름 선언하지 않고, 구현부만 작성

## 확장 함수

```kotlin
fun Int.product(value: Int): Int {
    return this * value
}
```



# 3 제어 구문

## if문

- 코틀린에서 if문은 표현식이다. 표현식은 구문과 달리, 결과로서 어떤 값을 반환한다.
- 결괏값이 없을 때는 구문으로 사용된다.

## when문

## for문



# 4 인터페이스

- 객체지향언어처럼 코틀린에서도 인터페이스 제공

## 인터페이스

- 다중 상속 가능
- 추상(abstract) 함수 가질 수 있다.
- 함수의 본문을 구현할 수 있다.
- 여러 인터페이스에서 같은 이름의 함수를 가질 수 있다.
- 추상 프로퍼티를 가질 수 있다. 추상 프로퍼티는 인터페이스에서 값을 직접 초기화할 수 없고, `get()` 를 구현해야 한다.



# 5 클래스

## 클래스와 프로퍼티

- 코틀린에선느 프로퍼티의 게터와 세터를 자동으로 생성해준다.
- `var` : 게터, 세터
- `val` : 게터만

## data class

- 게터, 세터, `hashCode`, `equals`, `toString` 등 자바 `Object` 클래스에 정의된 함수를 자동으로 생성해준다.
- `copy` : 함수 객체의 값을 복사하여 새로운 객체 생성
- `componentN` : 프로퍼티 수만큼 호출할 수 있고, 프로퍼티 이름으로 접근하는 대신 사용한다.

## enum class

## sealed class

- enum class 는 프로퍼티와 함수가 모두 타입이 동일해야한다는 제약이 있다.
- sealed class 는 enum 의 확장 형태로 클래스를 묶은 클래스다. 서로 다른 프로퍼티와 함수를 가진 이름을 가질 수 있다.
- sealed class의 하위클래스는 같은 파일내에 있어야 한다.



# 6 패턴 매칭

# 7 객체 분해

- 불필요한 코드를 없애고, 함수에서 여러개의 값을 반환하거나 간결한 루프를 작성하는 등 유용하게 활용가능하다.



# 8 컬렉션

- List, Set, Map 은 불변
  - 함수형 프로그래밍에서는 가급적 불변 자료구조를 사용하여 문제를 해결하는 것을 권장한다.
- MutableList, MutableSet, MutableMap 은 가변 자료구조



# 9 제네릭

- 객체 내부에서 사용할 데이터 타입을 외부에서 정하는 기법
- 제네릭을 사용하면 클래스를 선언할 때 타입을 확정 짓지 않고, 클래스가 객체화되는 시점에 타임이 결정된다.
- 클래스를 일반화하고 재사용성을 높일 수 있다.



# 10 코틀린 표준 라이브러리

- 확장함수
  - `let`, `with`, `apply`, `run`, `also`
- `use` 함수
  - 클로저블 객체에서 클로즈작업을 자동으로 해주는 함수



# 11 변성 (Variance)

- 제네릭을 포함한 타입의 계층 관계에서 타입의 가변성을 처리하는 방식
- Box[S] 는 Box[T] 의 하위 타입이다 : 공변 (covariant)
  - `out` (출력 전용)
- Box[T] 는 Box[S] 의 하위 타입이다 : 반공변 (contravariant)
  - `in` (읽기 전용)
- 관계가 없으면 무공변 (invariant)

> - `Box<T>` 에서 JVM 에서 각 파라미터 타입에 대한 정보는 Box 안에 담긴다. 
> - 컴파일 타임에 타입 유효성을 체크하는데 사용된다. 
> - 하지만 런타임에는 제네릭 타입의 인스턴스에 대한 타입 정보를 가지고 있지 않는다. 이러한 한계를 타입 소거 (type erasure) 라 한다.









