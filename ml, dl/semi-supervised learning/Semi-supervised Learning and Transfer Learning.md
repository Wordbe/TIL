# Semi-supervised Learning and Transfer Learning





# 1. 표현학습(Representation Learning)

2000년대 초반까지는 수작업 특징(hand-crafted feature)을 미리 구해 특징 벡터를 추출하고 얕은 구조의 기계학습을 구현했었습니다.

 하지만 수작업의 한계는 다양한 도메인에서 사람이 일일이 최적의 특징을 설계하는 것이 어렵다는 것입니다. 

 딥러닝에서는 특징 추출과 기계 학습이 동시에 최적화합니다.(end-to-end) 다른 도메인에 적용시키려면 데이터만 바꾸어 새로 학습하면 됩니다. **최적의 특징을 자동으로 알아내는 접근방식의 중요성**을 강조하기 위해 **표현학습(representation learning)**이라는 용어를 사용합니다.

 깊은 구조의 은닉층은 저급 특징에서 고급 특징으로 발전하는 계층 구조의 특징을 추출한다는 사실이 알려져 있습니다.

 2013년부터는 표현학습을 전문으로 다루는 ICLR(International Conference on Learning Representations) 학술대회가 매년 꾸준히 열리고 있습니다.









## 1-2) 매니폴드 관찰

다음 그림은 데이터 생성 원천(data generating source)과 표현 학습을 보여주는 그림입니다.

![](https://i.ibb.co/0hyxx1T/image.png)

b는 a를 단순 확대해서 보여주는 것이며, c는 다른 패턴입니다.

28x28크기의 이진비트 맵으로 표현하는 숫자 패턴은 $2^{784}$개의 서로 다른 점으로 구성되기 때문에 실제로 패턴을 생성하는 부분은 매우 좁다는 것을 알 수 있습니다.

 표현 학습은 데이터 생성 확률분포에서 수집한 훈련집합으로 작동합니다. 

 **매니폴드**는 **샘플이 집중적으로 놓인 원래 특징 공간보다 낮은 차원의 공간**을 말합니다.



아래는 데이터에 t-SNE를 적용하여 2차원 결과로 축소한 그림입니다.

![](https://i.ibb.co/ZmtFT30/image.png)

한 영역에서 한 축을 그으면, 그 축은 하나의 변화인자를 나타냅니다.

예를 들어 축의 왼쪽에서 오른쪽으로 가면 갈수록 1은 오른쪽으로 기울었다가 바로섰다가 다시 왼쪽으로 기울게 되는 듯한 영향이 있습니다.

패턴의 변화는 획 두께, noise, 획끊김 등이 있을 수 있습니다.





## 1-3) 프라이어(prior)를 통한 변화 인자 풀어내기(Disentagle)

 위에서 말한 혼합된 인자를 따로따로 풀어낼 수 있다면 사람의 지능에 좀 더 근접할 수 있을 것입니다.

> 특징 학습에 대한 가장 robust(강건)한 접근방법은 실용성 면에서 가장 정보를 적게 잃은 채로 가능 한 많은 인자(factor)를 풀어내는(disentangle) 것이다. (Bengio, 2013)

 변화 인자를 풀기 위해 데이터에 내재한 여러 종류의 프라이어(prior, 사전지식)을 이용해야 합니다.

 t-SNE 등 대부분은 일반성 프라이어(generic prior)를 이용합니다.

 문제는 현재 매니폴드를 가정한 후 변화 인자가 나타나는지 확인하는 정도 수준일 뿐, 의도적으로 변화 인자를 찾을 수 없다는 점입니다.

 표현학습은 명시적인 목적함수를 만들 수 없습니다. 표현 학습의 목적은 지도학습이 더 좋은 성능을 낼 수 있도록 더 좋은 표현을 추출하는 것입니다. 하지만, 이 목적을 수식화하는 작업은 매우 어렵습니다. 

 그래서 표현학습은 더 연구할 분야입니다.





# 2. 내부 표현의 이해



![](https://i.ibb.co/6HYNtM1/image.png)



내부 표현을 블랙박스로 간주하면 준지도학습, 전이학습을 설계할 수 없습니다.

내부 표현을 가시화(visualization)하는 방법을 알아보겠습니다.



![](https://i.ibb.co/VmvQJfd/image.png)



## 2-1) Convolution Filter Visulalization



필터를 가시화 하면, 대부분이 가버 필터(Gabor filter) 또는 컬러 블랍(Color blob)과 매우 비슷한 결과가 나옵니다. 



이는 특정한 데이터와 무관하게 나타나는 현상으로 밝혀졌습니다.

![](https://i.ibb.co/B21szJ7/image.png)

특히 첫번째 필터에서는 **에지**나 **블롭(방울느낌)**이 주로 나타나는 것을 볼 수 있습니다.



## 2-2) Feature Map Visualization

특징 맵을 가시화합니다.

입력이미지의 사람 얼굴 부분이 있다면, 특징맵에서 또한 사람 얼굴 부분을 밝게 표시하는 현상이 발생합니다. 



![](https://i.ibb.co/qM6M8Rt/image.png)





## 2-3) 영상공간으로 역투영(Back-projection)

은닉노드 또는 출력노드를 역투영하여, 이 부분이 어떤 인풋의 어떤 영역으로부터 영향을 받았는지 가시화합니다.



**최적화를 이용한 역투영**

관찰하고자 하는 뉴런을 i로 표기하고 $a_i(x)$를 영상 x가 입력되었을 때 뉴런 i의 활성화 값이라고 하면,
$$
\hat{x} = \underset{x}{argmax} \ a_i(x)
$$
를 해결하는 최적화문제로 설정할 수 있습니다.

이 최적화문제를 경사상승법(Gradient Ascent)으로 푸는 방법은 아래와 같습니다.
$$
x_{t+1} = x_t + \eta \frac{\partial a_i(x)}{\partial x}
$$
하지만, 이렇게 찾은 영상은 사람이 알아보기 어려운 형태를 띠어 한계가 있습니다.



따라서 프라이어, 즉 영상이 원천적으로 가진 특성을 고려한 규제 항이 개발되었습니다.

이 항은 화소가 가져야 하는 값의 범위를 한정하거나, 이웃 화소가 비슷한 값을 가져야 한다는 등의 조건을 반영합니다.


$$
\hat{x} = \underset{x}{argmax} \ (a_i(x) - R_{\theta}(x))
$$

$$
x_{t+1} = x_t + \eta \frac{\partial (a_i(x) - R_{\theta}(x))}{\partial x}
$$

이 외에도 이를 발전시킨 다양한 규제함수가 존재합니다.



여기까지는 하나의 노드를 역투영하는 경우였지만,

특징 맵 전체를 역투영하여 한 뉴런이 아닌, 한 특징맵이 보고자 하는 영상 즉 특징맵을 가장 활성화하는 영상을 찾아줍니다. (Mahendran, 2015)



## 2-4) Deconvolution을 이용한 역투영

CNN 연산의 역인 Deconvolution 기법이 있습니다.

이는 CNN이 한 연산을 그대로 역연산하는 과정을 적용하여 원래 영상 공간에 도달합니다.

![](https://i.ibb.co/wQQmGQ6/image.png)







# 3. 준지도 학습(Semi-supervised Learning)

$\mathbb{X}_l = \{x_1, x_2, \cdots, x_n\}, \mathbb{Y}_l = \{y_1, y_2, \cdots, y_n\}$ 처럼 데이터와 레이블이 주어진 상황에서 

$\mathbb{X}_u = \{x_{n+1}, x_{n+2}, \cdots, x_{n+m}\}$이 훈련집합을 구성하는 상황에서 이루어지는 학습입니다.



$\mathbb{X}_u$가 공집합이면 지도학습,

$\mathbb{X}_l, \mathbb{Y}_l$이 공집합이면 비지도학습입니다.



준지도 학습은 보통 m >> n 이라고 가정합니다. 즉 레이블이 없는 샘플이 훨씬 많은 경우 입니다. 준지도 학습은 레이블이 없는 샘플로부터 가능한 다량의 정확한 정보를 뽑아내야 한다는 점에서 표현학습과 관련이 깊습니다.



 다량의 데이터를 사람이 일일이 부류 정보를 레이블링해야 하는 것은 큰 비용이 듭니다. 따라서 실제 데이터가 이런 경우가 많다고 할 수 있습니다.



 **레이블이 없는 데이터는 도움이 되는가?**

​	답은 '예' 혹은 "아니요" 입니다.

​	주어진 데이터의 구조에 적합한 모델을 사용하는 경우는 높은 성능을 꾀할 수 있는 반면,

![](https://i.ibb.co/vZnQy7j/image.png)

그렇지 않다면 그림에서 보듯 정확률이 50% 정도로 낮아질 수 있습니다.



문제는 데이터 구조를 파악하고 구조에 맞는 모델을 설계하는 것이 어렵다는 것입니다.





## 알고리즘

대부분 메타 알고리즘입니다.

즉, 실제 구현시 데이터 구조에 적합한 특성 알고리즘을 선택하여 채워 넣어야 합니다.



**생성모델**

​	조건부 확률 $P(x|y)$(likelihood)를 명시적으로 구합니다. 이를 알면, 사전확률(prior)와 함께 베이즈 정리를 이용하여 $P(y|x)$(posterior)를 알 수 있고, 아래 식을 통해 분류가 가능합니다.
$$
\hat{y} = \underset{y}{argmax} \ P(y|x)
$$
우도(likelihood)를 구할 때는 밀도 추정 방법을 이용합니다.(예, 가우시안 혼합, Gaussian Mixture)

이는 지도학습이며, 준지도학습으로 방법은 다음과 같습니다.

$\mathbb{X}_l, \mathbb{X}_u$를 이용하여 $P(x)$를 구합니다. 이 때, $\mathbb{Y}_l$를 무시하고 비지도학습(이 또한 가우시안 혼합)을 통해 구합니다.

이렇게 가우시안 2개를 알아냈다면, 각각의 가우시안이 자신에게 속한 샘플의 레이블 정보를 보고 부류를 정합니다. 즉, P(x|y)를 알아냅니다.



하지만 생성 모델 방법은 원하는 정확도 이상까지 밀도 추정을 할 수 있는 상황에 국한 하여 적용해야 하는 한계가 있습니다.



---

**현대적 생성모델**

GAN 또는 pixelRNN을 이용합니다.

![](https://i.ibb.co/HqrZrKR/image.png)

원래 부류수가 c이면, 가짜 샘플을 위해 c + 1라는 레이블을 추가합니다. 

이 때 목적함수는 3개의 항을 이용합니다.

가짜 샘플은 c + 1에 속하고, $\mathbb{X}_u$ 샘플은 c + 1에 속하지 않고, $\mathbb{X}_l, \mathbb{Y}_l$ 샘플은 자신의 부류에 속하도록 합니다.



GAN은 특히 DCGAN(Deep Convolutional GAN)을 이용해서, MNIST 데이터 적용결과 레이블 있는 훈련 샘플을 클래스당 1개씩만 사용한 실험에서 84%의 높은 성능을 기록했습니다.

부류 당 10개씩으로 늘리면 98%의 성능을 찍었는데, 지도학습은 80%에 불과 했습니다. (Kumar, 2017)

진짜와 구별이 어려운 샘플을 만들 때까지 GAN을 학습한 후, GAN이 제공하는 매니폴드를 이용하는 기법입니다.



---

**자가학습(Self-training)**

먼저 $\mathbb{X}_l, \mathbb{Y}_l$로 지도학습을 수행한 후, 학습한 분류기로 $\mathbb{X}_u$로 샘플을 분류합니다.

이 중 신뢰도가 높은 샘플을 선발하여 $\mathbb{X}_l$에 포함시켜 분류기를 다시 학습시킵니다.

이 과정을 반복하여 적절한 조건에서 멈춥니다.



![](https://i.ibb.co/VJZSXfF/image.png)

자가 학습은 소속이 애매한 샘플을 뽑았을 때, 엉뚱하게 학습되는 결과를 보여주는 단점이 있습니다.



---

**협동학습(Co-training)**

학습기 2개가 서로 가르쳐 주는 과정을 반복하며 같이 발전하는 알고리즘입니다.



우선, 특징 공간 x에서 서로 독립인 두 부분공간을 나눕니다. 이 부분공간을 시점(view)라고 합니다.

두 분류기는 각각의 부분공간을 학습하고, $\mathbb{X}_u$를 분류하여 자가학습과 같이 신뢰도가 높은 샘플을 다시 각 부분공간에 넣습니다. 레이블링이 안 된 데이터가 다 소진할 때까지 반복합니다.



여기서 나아가, 두 개의 분류기는 신뢰도가 높은 샘플을 서로 교환합니다. 

이를 통해 협동학습을 진행합니다.



---

**그래프 방법**



그래프 방법은 $\mathbb{X}_l, \mathbb{X}_u$를 합친 다음, 샘플 각각을 노드로 삼고 이웃한 노드 사이에 에지를 연결합니다. 이 때 두 샘플의 유사도에 따라 에지에 가중치가 부여됩니다.

그래프를 구성하는 방법은 단순하게는 k-nearest neighbor을 찾는 방법이 있으나 이는 비선형으로 복잡하게 형성된 데이터 분포를 제대로 반영하지 못합니다.

이 외에 다양한 방법이 있으나 여기서는 넘어갑니다. (참고: Zhu, 2005b)



![](https://i.ibb.co/F5zp9Sn/image.png)

그래프를 만든 후에는 $\mathbb{X}_u$를 레이블링 합니다. 

위 그림은 $\mathbb{X}_l$는 빨간 노드, $\mathbb{X}_u$는 하얀 노드에 속할 때, 최소분할(mincut)을 적용한 결과입니다. 분할선을 구성하는 에지의 가중치 합이 최소가 되도록 노드를 두 부분집합으로 분할 합니다.

빨간색 파란색 두 부류로 나눈다고 했을 때, 이 예제에서는 분할선을 구성하는 에지 가중치 합이 1+2+2=5 로서 최소가 됩니다.

 분할선을 구했다면, 분할선을 기준으로 왼쪽에는 파란색, 오른쪽은 빨간색으로 분류를 하면됩니다.



최소 분할 알고리즘은 다음 목적함수를 최소화하는 해를 찾는다고 볼 수 있습니다.

$\theta(x_i)$는 i번째 노드에 최종으로 부여되는 레이블값을 의미합니다.

$w_{ik}$는 노드 j와 노드 j를 잇는 에지의 가중치입니다.

첫번째 항은 단순히 $\mathbb{X}_l$에 있는 샘플의 레이블을 그대로 유지하게 강제화하는 역할을 합니다.

두번째 항은 규제 역할을 합니다.


$$
J(\theta) = \sum_{i=1}^n \infty (y_i - \theta(x_i))^2 + \lambda \sum_{j=n+1}^{n+m}\sum_{k=n+1}^{n+m} w_{jk} (\theta(x_j)- \theta(x_k))^2
$$
최소분할 알고리즘은 transductive합니다.

즉 새로운 샘플에 대해 예측하여 레이블을 알아낼 수 없습니다.

얻기 위해서는 새로운 샘플을 그래프에 추가하고, 알고리즘을 처음부터 수행해야합니다.

이처럼 그래프 알고리즘은 대부분 트랜스덕티브합니다.



반면, 새로운방법인 **그래프임베딩(graph embedding)**은 귀납적(inductive)하게 동작할 수 있습니다.



---

**표현 변환**

1) $\mathbb{X}_l, \mathbb{X}_u$을 합친 데이터로 목적을 달성하는 유리한 표현으로 변환(얕은 변환)

2) $\mathbb{X}_l$을 새로운 표현으로 변환

3) 변환된 $\mathbb{X}_l$과 $\mathbb{Y}_l$로 목적에 따라 기계학습을 수행



즉 1)에서는 비지도학습, 2)~3)에서는 지도학습을 수행합니다.



---

**밀집지역 회피**

두 클래스를 구분하는 결정경계가 샘플이 밀집된 지역을 지난다면 옳지 않은 선택일 가능성이 큽니다. 이 원리를 이용해 SVM을 통해 학습합니다.

![](https://i.ibb.co/1r1CYxQ/image.png)











# 4. 전이학습

전이학습(Transfer Learning)은 어떤 도메인에서 학습한 프로그램을 데이터가 적어 애를 먹는 새로운 도메인에 적용하여 높은 성능을 얻는 기법입니다.



**과업이 다른경우**

​	영상인식 → 음성인식: 두 과업 사이의 거리가 멀어 아직 실용적 연구결과가 없습니다.

​	반면, 같은 물체이지만, 배경이나 위치가 바뀐 경우 과업간 거리가 짧아 응용이 쉽습니다.



**도메인이 다른경우**

* **특징공간이 다른경우**

  영불 번역 → 영한 번역 : 단어 집합이 달라서 특징공간이 다릅니다.

* **특징공간은 같지만 확률분포가 다른 경우**

  MNIST와 필기 습관이 달라 새로 생성된 숫자데이터



## 4-1. 과업전이

과업전이는 컴퓨터비전 분야에서 영상 인식 응용에 성공적으로 적용되었습니다.

ILSVRC(Image Large-Scale Visual Recognition Competition)  대회에서, transfer learning을 통해 오류율을 혁신적으로 낮출 수 있었습니다.



![](https://i.ibb.co/LdGH2hD/image.png)



CNN 특징을 전이 학습에 적용하는 방법은 크게 두가지가 있습니다.



---

**동결방식(Freezing)**

1) 새로운 훈련집합 $\mathbb{X} = \{x_1, x_2, \cdots, x_n\}$을 CNN에 입력하여 새로운 훈련집합 $\mathbb{X}' = \{x_1', x_2', \cdots, x_n'\}$ 생성

2) 새로운 훈련집합과 $\mathbb{Y} = \{y_1, y_2, \cdots, y_n\}$로 학습기에서 학습



1)에서는 CNN에서 일정한 부분의 가중치를 고정시키고 거기로부터 출력을 구합니다.

이를 2)에서는 1)에서 이미 컨볼루션층을 통과하여 우수한 특징들이 추출되었으므로 얕은 구조학습을 통해 분류합니다. 



---

**미세조정(Fine-tune) 방식**

1) 그림에서 파란색 표시된 곳을 떼어낸 후 새로운 구조를 덧댐, 이 때 과업에 맞게 출력노드 수를 조정합니다.

2) 덧댄 곳의 가중치를 초기화하고 하이퍼 파라미터를 적정하게 설정합니다.

3) $\mathbb{X} = \{x_1, x_2, \cdots, x_n\}$,  $\mathbb{Y} = \{y_1, y_2, \cdots, y_n\}$로 학습합니다.



**과업전이가 잘되는 이유?**

Yosinski, 2014 는 세 가지 질문으로 위 현상을 정량적으로 분석하는 실험을 수행하였습니다.

* 층의 일반성, 특수성을 양적으로 측정할 수 있는가?
* 일반성이 어떤 층에서 갑자기 특수성으로 바뀌는가, 서서히 바뀌는가?
* 어느 곳에서 전환이 일어나는가? 앞, 중, 뒤



앞에서부터 i번째 층을 기준으로 실험하였을 때, freezing에서 i=1일 때 성능 유지, i=2~3 성능 저하, i=4~7 큰 성능 저하가 발생했습니다.

fine-tunning에서는 i=1~2는 유사한 성능, i=3~7에서는 더 좋아진 성능을 보였습니다.

이는 전이학습에서 나타난 현상을 정량화했다는데 의미가 있지만, 제기한 질문의 답으로는 불충분합니다. 앞으로의 연구 주제입니다.



## 4-2. 도메인 전이



**특징 공간은 같은데 확률분포가 다른경우**

이 경우를 특별히 **도메인적응(Domain adaptation)**이라고 부릅니다.



source domain이 target domain으로 바뀌는 상황을 도메인 이동(domain shift)이라고 하며, 도메인 적응은 높은 성능을 유지하면서 도메인 이동을 달성하는 기법입니다.

![](https://i.ibb.co/YTLFzkV/image.png)



소스 도메인을 $\mathbb{X}_s = \{ x_{s1}, x_{s2}, \cdots, x_{sn}\}$, 타겟 도메인을 $\mathbb{X}_t = \{ x_{t1}, x_{t2}, \cdots, x_{tm}\}$라고 합시다.

보통 소스도메인이 훨씬 많은 데이터를 가지고 있으므로 n >> m인 상황입니다.



먼저 쉬운 방법입니다.(Daume, 2009)
$$
\begin{cases}
\Phi^s(x_s) = (x^T_s, x^T_s, 0)^T \\
\Phi^t(x_t) = (x^T_t, 0, x^T_t)^T \\
\end{cases}
$$
먼저 특징 벡터의 크기를 3배로 확장합니다.

$0$은 d차원의 0벡터 입니다.

이렇게 확장한 n+m데이터를 학습한 후, 타겟 도메인에서 그대로 활용하면 됩니다.



다음은 비지도 학습으로 확장한 방법입니다.(Sun, 2016)

![](https://i.ibb.co/xS8fqRn/image.png)



소스 도메인의 샘플을 타겟 도메인의 분포에 맞도록 변환하는 것이 핵심입니다. 이 때 서로 일치시키는 정보는 공분산 행렬(covariance matrix)입니다.



먼저 소스 도메인을 화이트닝(whitening) 변환합니다. 이 때 공분산 행렬은 단위행렬이므로 구 모양의 분포를 합니다.

다음으로 파란점이 빨간점과 같은 공분산 행렬을 가지도록 변환합니다. 이 연산은 화이트닝 반대효과를 제공하므로 컬러링(coloring)이라고 합니다.


$$
\begin{gather*}
\Sigma'_s = \Sigma_s + \lambda I \\
\Sigma'_t = \Sigma_t + \lambda I \\
X'_s = X_s(\Sigma'_s)^{-\frac{1}{2}} (whitening) \\
X^*_s = X'_s(\Sigma'_t)^{\frac{1}{2}} (coloring)
\end{gather*}
$$


변환환 $\mathbb{X}^*_s, \mathbb{Y}_s$를 가지고 학습한 후, 타겟 도메인에서 활용하면 됩니다.

domain adaptation이 필요한 응용이 늘어남에 따라 ICCV(International Conference on Computer Vision) 학술대회는 domain adaptation 경진대회 워크숍을 별도로 개최하고 있습니다.









---

**Reference**

기계학습, 오일석, 2017, 준지도학습과 전이학습