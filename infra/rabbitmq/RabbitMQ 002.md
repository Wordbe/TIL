# RabbitMQ 002



# 4 메시지 발행에서 성능 절충

- AMQP 스펙은 메시지 발행시 트랜잭션을 제공한다.
- 메시지를 디스크에 저장하는 경우 일반 메시지 발행보다 높은 수준의 안정성을 제공한다.
- RabbitMQ 는 발행자 확인 등 추가 기능을 제공한다. 여러 서버에 걸쳐 HA 큐 같은 메시지 배달 보장 수준을 선택할 수 있다.

## 1 발행 속도와 배달 보장의 균형 잡기

- Delivery guarantee 수준에는 골디락스 원칙을 적용할 수 있다.
- `Delivery guarantee ↔ 발행속도` tradeoff 조절
- **(빠름) 배달 보장 없음 - 실패 통보 - 발행자 확인 - 대체 익스체인지 - HA 큐 - 트랜잭션 - 트랜잭션 HA 큐 - 메시지 디스크에 저장 (느림)**

### 1 배달 보장 없음

### 2 실패 통보 : mandatory 플래그를 설정한 메시지를 라우팅할 수 없을 때

- 서버 모니터링 데이터가 항상 RabbitMQ로 배달되도록 보장하려면, collected 에서 RabbitMQ에 발행하는 메시지의 mandatory 를 설정한다.
- 발행자는 Basic.Publish RPC 명령을 사용해 라우팅할 수 없는 메시지를 `mandatory=True` 로 전송한다.
- 익스체인지가 메시지를 라우팅 할 수 없으면 RabbitMQ 는 Baisc.Return 을 통해 메시지를 보낸 그대로 전체 메시지와 함께 서버로 되돌려보낸다.

### 3 발행자 확인

- Publisher Confirms 는 AMQP 의 확장 기능이다.
- 발행자는 RabbitMQ 에게 Confirm.Select RPC 요청하고 서버는 Confirm.SelectOk 응답한다.
- 그 후 발행자가 Basic.Publish 로 메시지 발생하면, RabbitMQ는 Basic.Ack 또는 Basic.Nack 으로 응답한다.

### 4 대체 익스체인지 : 라우팅할 수 없는 메시지를 위함

- alternate exchange
  - 처음 익스체인지를 선언할 때 명시한다.
  - 익스체인지 라우팅할 수 없으면, 대체 익스체인지가 대신 지정된다.

### 5 트랜잭션으로 배치 처리하기

- 발행자 → RabbitMQ : Tx.Select 전송
- Tx.SelectOk 응답
- Basic.Publish 로 메시지 발행
- Basic.Return 응답
- Tx.Commit 으로 메시지 커밋
- Tx.CommitOk 로 응답

### 6 HA 큐를 사용해 노드 장애 대응하기

- 안정적 메시지 전달을 보장하기 위해 발행자와 RabbitMQ 간 계약을 강화해야하는 미션 크리티컬 메시징 아키텍처에서는 가용성 높은 HA 큐가 중요한 역할을 한다.

### 7 HA 큐 트랜잭션

- 트랜잭션 또는 발행자 확인을 사용하는 경우, 메시지가 HA 큐의 모든 활성 노드에 있는 것으로 확인할 때까지 RabbitMQ 는 성공 응답을 보내지 않는다.

### 8 delivery-mode 2 를 사용해 메시지를 디스크에 저장하기

- 대부분 사용자는 단지 글을 읽고 작성하지는 않는다.
- 읽기가 많고 쓰기는 적다.



## 2 RabbitMQ 푸시백

- RabbitMQ 3.2 버전부터 TCP 배압(Back Pressure) 메커니즘 작동
  - 발행자가 너무 많은 메시지를 보낼 경우 TCP 소켓 하위 수준의 데이터 수신을 중지한다.
- 새로운 연결 생성시, 연결에 사용할 수 있는 크레딧(credit) 양이 할당되고 RabbitMQ 가 각 RPC 명령을 수신하면 크레딧이 감소한다. RPC 요청이 처리되면 크레딧은 되돌려진다.
- Connection.Blocked, Connection.Unblocked 는 발행자 클라이언트르 차단하거나, 블록이 제거됐을 때 클라이언트에게 알릴 수 있는 비동기 메소드다.



---

# 5 메시지를 받지 않고 소비하기

- 단순히 메시지를 전달 받지 않고, 소비하는 것이 좋다.
- 메시지 배달 보장과 성능 간 균형을 유지하자
- RabbitMQ의 큐별 설정을 통해 큐를 자동으로 삭제하고, 메시지 수명을 제한하자.



## 1 Basic.Get, Basic.Consume

- 큐에서 메시지를 가져온다.
- Basic.Get
  - 폴링 모델
  - 동기 방식
  - 큐에 메시지가 여러 개 있어도 메시지 받을 때마다 새로운 요청을 보낸다.
    - 메시지 처리량에 영향을 주는 것이 메시지 자체가 아니라, Basic.Get 의 평가 작업이고
    - RabbitMQ는 애플리케이션이 메시지를 요구하는 시기를 알 수 없으므로 전달 프로세스를 최적화할 수 없다.
  - 서버는 Basic.GetOk 로 응답한다. 큐에 메시지가 없으면 Basic.GetEmpty 로 응답한다.
- Basic.Consume
  - 푸쉬 기반 모델
  - 발행자-구독자 (Pub-Sub) 패턴이다.
  - 클라이언트는 Basic.Cancel 을 전송하기 전까지 RabbitMQ 에서 메세지를 자동으로 수신할 수 있다.
  - RabbitMQ 는 컨슈머 클라이언트에게 메시지를 비동기적으로 보내도록 요청한다.
  - 클라이언트는 빈 응답(Basic.GetEmpty)을 확인할 필요는 없지만, 메시지가 처리됐음을 알기 위해 message.ack 을 호출해야 한다.
  - 소비자 태그(consumer tag)라는 문자열이 생기고, 클라이언트를 구분한다. 메시지와 함께 전송된다.



## 2 소비자 성능 조정

(빠름)

- 메시지 수신 확인 응답, QoS > 1 로 메시지 소비하기
- 무응답 모드로 메시지 소비하기
- 수신확인으로 메시지 소비하기
- 트랜잭션을 사용해 메시지 소비하기
- 메시지 받기

(느림)



### 1 서비스 품질 설정(QoS)을 통한 소비자 프리페치 제어

- Quality of Service
- 동시에 여러 메시지를 수신확인할 수 있어 메시지 처리에 필요한 네트워크 통신을 최소화할 수 있다. 메시지 처리량을 향상시킨다. 하지만 조금 위험하다.

### 2 무응답 모드로 메시지 소비 (빠른 성능)

- no-ack 플래그 있음
- 소비자가 메시지 수신확인하지 않으므로 RabbitMQ 가 가능한 빨리 메시지를 보낼 수 있다.

### 3 트랜잭션 사용하기 (소비자 애플리케이션에서)



## 3 메시지 거부하기

### 1 Basic.Reject

- 한 번에 하나의 메시지만 거부한다.



### 2 Basic.Nack

- 한 번에 여러 메시지 거부할 수 있다.
- AMQP 스펙에는 없지만, RabbitMQ 팀은 이를 보완하여 새로운 Basic.Nack RPC를 구현했다. (부정적 수신확인)



### 3 Dead Letter Exchange

- RabbitMQ 의 확장 스펙, 전달된 메시지를 거부할 수 있는 추가 기능
- 메시지 소비시 문제 원인을 찾는데 유용하다.



## 4 큐 제어하기

RabbitMQ 는 여러 종류의 큐를 구현할 수 있다.

- 자동 삭제 큐
- 큐 독점 설정
- 자동 메시지 만료
- 대기 메시지 수 제한
- 오래된 메시지 큐에서 제거

AMQP 스펙에 따라 큐설정은 불변이다. 큐를 변경하려면 삭제하고 다시만들어야 한다.

### 1 임시 큐

- 자동 삭제 큐 (auto_delete)
- 큐 독점 설정 (exclusive)
  - 단일 소비자만 큐를 소비
- 자동 만료 큐 (x-expires)
  - TTL(Time To Live) 설정할 수 있다.

### 2 영구적 큐

- 내구성 큐 (durable)
  - 서버를 재시작한 후에도 계속 유지
- 큐에서 메시지 자동만료 (x-message-ttl)
- 제한된 수의 메시지 보관 (x-max-length)

### 3 임의의 큐 설정

