# Unit Testing 010 - 데이터베이스 테스트



- 애플리케이션 데이터베이스는 다른 애플리케이션이 접근할 수 없는 데이터베이스
- 실제 데이터베이스를 테스트하면 회귀 방지가 뛰어나지만 설정하기가 어렵다.
  - 데이터베이스 스키마 추적
  - 상태 기반 데이터베이스 배포 방식
  - 마이그레이션 기반 데이터베이스 배포 방식 ★



# 1 데이터베이스 테스트를 위한 전제 조건

- 통합 테스트에서는 관리 의존성이 그대로 있어야 한다. 목 사용 X
- 전제조건
  - 형상 관리 시스템에서 데이터베이스 유지
  - 개발자마다 별도 데이터베이스 인스턴스 사용
  - 데이터베이스 배포에 마이그레이션 기반 방식 적용





## 1 데이터베이스를 형상 관리 시스템에 유지

- 데이터베이스 스키마를 일반 코드로 취급한다.
- Git 에 저장

모델 데이터베이스 사용하는 것은 데이터베이스 스키마 유지에 좋지 못한 방법

- 변경 내역의 부재 : 특정시점으로 되돌릴 수 없다.
- 복수의 원천 정보 : 두가지 이상 기준(Git과 모델 데이터베이스)에서 부담이 가중된다.



## 2 참조 데이터도 데이터베이스 스키마다

- 테이블, 뷰, 인덱스, 저장 프로시저
- 스키마는 SQL 스크립트 형태로 표현된다.
- 참조데이터는 애플리케이션이 제대로 작동하도록 미리 채워야 하는 데이터
  - 예) 사용자 유형 Customer, Employee
  - 외래 키 제약 조건을 걸고 싶은 데이터
  - SQL `INSERT` 문 형태로 형상관리시스템에 저장



## 3 모든 개발자를 위한 별도의 데이터베이스 인스턴스

- 개발자들과 데이터베이스를 공유한다면 테스트가 더 어렵다.
  - 서로 다른 개발자가 실행한 테스트는 서로 간섭되기 때문
  - 하위 호환성이 없는 변경으로 다른 개발자의 작업을 막을 수 있기 때문



## 4 상태 기반 데이터베이스 배포와 마이그레이션 기반 데이터베이스 배포

- 상태기반 방식은 상태를 형상 관리에 저장함으로써 상태를 명시하고, 비교 도구가 마이그레이션을 암묵적으로 제어한다.

  - 상태가 명확하면 병합 충돌을 처리하기 수월하다.

- 마이그레이션 기반 방식은 마이그레이션을 명시적으로 하지만, 상태를 암묵적으로 둔다. 데이터베이스 상태를 직접 볼 수 없으며 마이그레이션으로 조합해야 한다.

  - 데이터 모션 문제 해결이 용이하다.

    > 데이터 모션
    >
    > 새로운 데이터베이스 스키마를 준수하도록 기존 데이터의 형태를 변경하는 과정

  - 대부분 프로젝트에서는 데이터 모션이 병합 충돌보다 훨씬 더 중요하다.

- 마이그레이션 기반 방식은 데이터베이스를 버전마다 전환하는 명시적 마이그레이션을 의미한다.
  - 운영 데이터베이스 스키마에서 문서화되지 않은 변경 사항을 발견할 때 데이터베이스 비교 도구가 아직 유용할 수 있다.
  - 형상 관리에 저장하는 산출물은 데이터베이스 상태가 아닌 마이그레이션
  - SQL 스크립트 (Flyway, Liquibase 등) 로 표시하지만, SQL 로 변환 가능한 DSL (FluentMigrator(C#) 등) 도 있다. 



# 2 데이터베이스 트랜잭션 관리

트랜잭션은 제품코드와 테스트코드 모두에 중요한 주제다.



## 1 제품 코드에서 데이터베이스 트랜잭션 관리하기

잠재적 모순을 피하려면 결정 유형을 두가지로 나눈다.

- 업데이트할 데이터
- 업데이트 유지 또는 롤백 여부



데이터베이스 클래스를 리포지토리와 트랜잭션으로 나누어 책임을 구분한다.

- 리포지토리는 데이터베이스의 데이터에 대한 접근과 수정을 하는 클래스
- 트랜잭션은 데이터 업데이트를 완전히 커밋하거나 롤백하는 클래스

더 좋은 방법 (작업 단위)

- Transaction 클래스 작업 단위로 (unit of work) 업그레이드 할 수 있다.

> 작업단위에는 비즈니스 연산의 영향을 받는 객체 목록이 있다. 작업이 완료되면, 작업 단위는 데이터베이스를 변경하기 위해 해야 하는 업데이트를 모두 파악하고 이러한 업데이트를 하나의 단위로 실행한다.

- 일반 트랜잭션과 비교하여 작업 단위가 갖는 가장 큰 장점 : 업데이트 지연



> 비관계형 데이터베이스에서의 데이터 모순
>
> - 관계형 에서는 데이터 모순을 피하기가 쉽다. 모든 관계형 DB는 필요한 만큼 여러 행에 걸쳐 원자적 업데이트를 제공한다.
> - MongoDB 같은 비관계형 DB 에서 동일한 수준으로 보호하는 방법은?
>   - 원자적 업데이트는 단일 도큐먼트 내에서만 보장된다. (도규먼트는 행과 동일)
>   - 비관계형에서는 한 번에 둘 이상의 도큐먼트를 수정하는 비즈니스 연산이 없도록 도큐먼트를 설계해야 한다.
> - DDD 에서는 비즈니스 연산 당 둘 이상의 집계를 수정하면 안된다는 지침이 있다.



## 2 통합 테스트에서 데이터베이스 트랜잭션 관리하기



# 3 테스트 데이터 생명 주기

공유 데이터베이스를 사용하면 통합 테스트를 서로 분리할 수 없다. 해결하려면

- 통합 테스트를 순차적으로 실행
- 테스트 실행 간에 남은 데이터 제거



## 1 병렬 테스트 실행과 순차적 테스트 실행

## 2 테스트 실행 간 데이터 정리

테스트 실행 간 남은 데이터 정리 방법 4가지

- 각 테스트 전에 데이터베이스 백업 복원하기 : 느리다
- 테스트 종료 시점에 데이터 정리하기
- 데이터베이스 트랜잭션에 각 테스트를 래핑하고 커밋하지 않기
- 테스트 시작 시점에 데이터 정리하기

> 별도의 종료단계는 필요없고, 준비 구절에 구현한다.



- 모든 통합테스트에 기초 클래스를 두고, 기초 클래스에 삭제 스크립트를 작성한다. 테스트가 시작될 때마다 자동으로 스크립트가 실행되도록



## 3 인메모리 데이터베이스 피하기

- 인메모리 데이터베이스는 공유 의존성은 아니므로 통합 테스트는 실제로 컨테이너 접근 방식과 유사한 단위 테스트가 된다.
- 하지만, 데이터베이스와 기능적으로 일관성이 없으므로 사용하지 않는 것이 좋다.
  - 운영과 테스트 환경이 일치하지 않는다.
  - 거짓 양성, (더 나쁜)거짓 음성이 발생하기 쉽다.



# 4 테스트 구절에서 코드 재사용하기

- 통합테스트는 가능한 짧게 하고 서로 결합하거나 가독성에 영향을 주지 않는 것이 중요



## 1 준비 구절에서 코드 재사용

- 각 구절에 대해 별도의 데이터베이스 컨텍스트(작업 단위)를 두고 나서 통합테스트
- 코드를 재사용하기 좋은 방법 : 공개 팩토리 메서드 도입



## 2 실행 구절에서 코드 재사용하기

- 데코레이터 메서드를 사용하면 테스트 실행 구절은 몇 줄만으로 충분하다.



## 3 검증 구절에서 코드 재사용하기

- 새 헬퍼 메서드
- 플루언트 인터페이스 확장 메서드



## 4 테스트가 데이터베이스 트랜잭션을 너무 많이 생성하는가

- 빠른 피드백과 유지보수성 간의 절충을 한다.
- 유지보수성을 위해 성능을 양보하는 것이 좋다.



# 5 데이터베이스 테스트에 대한 일반적 질문

## 1 읽기 테스트 해야 하는가

- 읽기 작업의 버그에는 보통 해로운 문제가 없다.
- 복잡하거나 중요한 읽기 작업만 테스트하고 나머지는 무시한다.
- 읽기에는 도메인 모델도 필요하지 않다.
- 도메인 모델링 주요 목표는 캡슐화인데, 변경사항에 비춰 데이터 일관성을 유지하는 것이 목표다. 데이터 변경이 없으면 캡슐화는 의미가 없다.
- 불필요한 추상화 계층을 피해서 성능면에서 ORM 보다 우수한 일반 SQL 을 사용하는 것이 좋다.



## 2 리포지토리 테스트를 해야 하는가

- 리포지토리는 우수한 추상화 제공한다.
- 리포지토리는 컨트롤러에 해당하고, 복잡도가 거의 없이 외부 의존성인 데이터베이스와 통신한다.
- 리포지토리는 테스트하지 않아도 된다.
- 약간의 복잡도를 별도의 알고리즘으로 추출하고 해당 알고리즘 전용 테스트를 작성하는 것도 좋다.



















