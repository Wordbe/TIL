# Unit Testing 009 - 목 처리에 대한 모범 사례



- 목은 비관리 의존성에 적용한다. (외부 애플리케이션에서 식별할 수 있음)
- 목으로 리팩터링 내성과 회귀 방지를 최대화해서 최대 가치의 통합테스트를 개발한다.



# 1 목의 가치 극대화

- 비관리 의존성에만 목 적용





## 1 시스템 끝에서 상호 작용 검증하기

- 목을 사용할 때, 시스템 끝에서 비관리 의존성과의 상호 작용을 검증한다.
- 비관리 의존성과 통신하는 마지막 타입을 목으로 처리하면, 통합테스트가 거치는 클래스수가 증가하므로 보호가 향상된다.
- 시스템 끝에서 상호작용을 확인하면, 회귀 방지가 좋아지고 리팩터링 내성도 향상된다.
  - 거짓 양성에 노출될 가능성이 낮아진다.



## 2 목을 스파이로 대체하기

- 스파이는 수동 작성
- 목은 목 프레임워크 도움을 받아 생성
- 스파이는 검증 단계에서 코드를 재사용해 테스트 크기를 줄이고 가독성을 향상시킨다.
  - `BusSpy` 가 제공하는 fluent interface 덕분에 메시지 버스와의 상호작용을 검증하는 것이 간결해졌고 표현력도 생겼다.
- `BusSpy` 는 테스트코드에 `MessageBus` 는 제품 코드에 속한다.
  - 테스트에서 검증문을 작성할 때 제품 코드에 의존하면 안되므로 이 차이는 중요하다.





# 2 목처리에 대한 모범 사례

- 비관리 의존성에만 목 적용하기
- 시스템 끝에 있는 의존성에 대해 상호작용 검증하기
- 통합테스트에서만 목사용하고, 단위 테스트에서는 하지 않기
- 항상 목 호출 수 확인하기
- 보유 타입만 목으로 처리하기



## 1 목은 통합 테스트만을 위한 것

- 비즈니스 로직과 오케스트리에션의 분리
- 도메인 모델에 대한 테스트는 단위 테스트 범주에 속하고, 컨트롤러에서 다루는 테스트는 통합 테스트다.



## 2 테스트당 목이 하나일 필요는 없음

## 3 호출 횟수 검증하기

- 예상하는 호출이 있는가
- 예상치 못한 호출은 없는가



```c#
messageBusMock.Verify(
	x => x.SendEmailChangeMessage(user.UserId, "new@gmail.com"),
  Times.Once); // 해당 메소드를 한 번만 호출하는 지 확인
messageBusMock.VerifyNoOtherCalls(); // 추가 확인 (Moq 라이브러리)
```





## 4 보유 타입만 목으로 처리하기

- 서드파티 라이브러리 위에 항상 어댑터를 작성하고 기본 타입 대신 해당 어댑터를 목으로 처리하자.
  - 서드파티 코드의 작동 방식에 대해 깊이 이해하지 못하는 경우가 많다
  - 이미 내장 인터페이스를 제공하더라도, 목으로 처리한 동작이 실제로 외부 라이브러리와 일치하는지 확인해야 하므로, 해당 인터페이스를 목으로 처리하는 것은 위험하다.
  - 서드파티 코드의 기술 세부 사항까지는 꼭 필요하지 않기에 어댑터는 이를 추상화하고 애플리케이션 관점에서 라이브러러와의 관계를 정의한다.
- 어댑터는 코드와 외부 환경 사이의 손상방지계층(anti-corruption layer)으로 작동한다. 어댑터를 통해
  - 기보노 라이브러리의 복잡성을 추상화하고
  - 라이브러리에서 필요한 기능만 추출하며
  - 프로젝트 도메인 언어를 사용해 수행할 수 있다.











