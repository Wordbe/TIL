## RDB 성능 개선 - 002 인덱스



최적의 인덱스를 만들기 위해서

- 인덱스의 물리적 구조 이해
- 복잡한 SQL 을 분해해서 이해
- 인덱스가 어떻게 사용될 지 예측
- 테이블 내 데이터 속성 파악
- JOIN 의 내부 처리 방법 (Nested Loops, Merge, Hash) 이해



# Index



- Buffers (논리적 IO)
  - DB 메모리에 있는 버퍼 캐시에서 데이터를 읽은 횟수
- Reads (물리적 IO)
  - 디스크에서 데이터를 읽은 횟수
- 최소한의 논리적/물리적 IO로 SQL 이 처리될 수 있도록 적절한 인덱스 전략과 적절한 SQL 이 필요



- TABLE ACCESS FULL

Index

- INDEX RANGE SCAN

<br />

## 인덱스 종류

인덱스 구성 수

- 단일 인덱스
- 복합 인덱스 (멀티 컬럼 인덱스, 결합 인덱스)
  - 가능하면 하나의 복합 인덱스로 여러 SQL을 커버하는 것이 좋다.
  - 인덱스의 수를 최소화하는 것이 성능에 좋다.

컬럼 중복 여부

- 유니크 인덱스
  - 중복된 값을 저장하지 못한다. PK 제약 조건에는 무조건 유니크 인덱스가 구성된다.
- 비유니크 인덱스

파티션 테이블에는 파티션 된 인덱스를 만들 수 있다.

- 글로벌 인덱스
  - 여러 파티션 데이터를 통합하여 인덱스를 생성
- 로컬 인덱스

<br />

## B* 트리

- B star tree
- Balanced : 균형잡힌
- star : 근접한 리프노드가 연결된 구조

각각의 인덱스 블록은 B* tree 노드에 위치

- 루트 블록
  - 하위 브랜치 블록의 인덱스 키, 주소를 가짐
- 브랜치 블록
  - 하위 브랜치(또는 리프)의 인덱스 키, 주소를 가짐
- 리프 블록
  - 최하위에만 위치
  - **인덱스 키와 데이터의 로우 주소(ROWID)를 가진다.**
  - **리프 블록은 인덱스 키 값 순으로 정렬되어 있다.**



## 데이터를 찾는 방법

### 1. FULL SCAN

- TABLE ACCESS FULL
- 테이블 전체 읽기는 찾고자 하는 조건에 인덱스가 없거나, 인덱스보다 테이블 전체를 읽는 것이 더 효율적이라고 판단될 때 사용된다.
- 천만 건 중 10건 정도를 찾아야 한다면 인덱스가 효율적이다.
- 천만 건 중 100만건 정도를 찾아야 한다면 FULL SCAN 이 더 효율적일 수 있다.

### 2. INDEX SCAN

- INDEX RANGE SCAN, INDEX SKIP SCAN, INDEX FULL SCAN
- 인덱스를 활용하면 풀 스캔 하는 것보다 획기적으로 데이터를 빠르게 조회할 수 있다. O(N) → O(logN)
- 서버와 스토리지 성능, 테이블 구조, SQL 에 따라 실행계획 성능은 달라진다.

### 3. ROWID 이용해서 직접 찾기

- TABLE ACCESS BY INDEX ROWID
- 테이블의 레코드 주소인 ROWID 를 조건 값으로 직접 찾아가는 방법이다.
- 인덱스 스캔에서도 사용한다.



