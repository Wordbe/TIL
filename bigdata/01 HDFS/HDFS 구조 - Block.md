# HDFS 구조 - Block

HDFS 파일은 지정한 크기의 블록으로 나누어지고, 각 블록은 독립적으로 저장됩니다.

HDFS 블록은 128MB 같이 매우 큰 단위입니다. 탐색 비용을 최소화 할 수 있습니다. 블록이 크면 하드디스크에서 블록의 시작점을 탐색하는 데 걸리는 시간을 줄일 수 있습니다. 따라서 여러 개의 블록으로 구성된 대용량 파일을 전송하는 시간은 디스크 I/O 속도에 영향을 받습니다.



## 블록 크기 파일 분할

기본 블록 크기를 넘는 파일은 블록 크기로 분할하여 저장합니다.

* 블록 크기보다 작은 파일은 단일 블록으로 저장
* 블록 단위로 나누어 저장하기 때문에, 디스크 사이즈보다 더 큰 파일을 보관할 수 있음



## 블록 추상화의 이점

1) 큰 파일을 블록단위로 나누어서 단일 디스크의 용량보다 큰 파일을 저장할 수 있습니다.

2) 파일 단위보다 블록 단위로 추상화 하면 스토리지 서브 시스템을 단순하게 만들 수 있습니다.

3) 블록 단위로 복제를 구현하기 때문에, 내고장성을 제공하는데 필요한 복제(replication)를 구현할 때 매우 적합합니다.



## 볼록 지역성

맵리듀스를 이용한 분산 컴퓨팅은 블록의 지역성을 이용해 성능을 높입니다. 맵리듀스를 처리할 때 현재 노드에 저장되어 있는 블록을 이용하는 블록 지역성(Block Locality)을 통해 성능을 높일 수 있습니다.

* 네트워크 이용한 데이터 전송 시간 감소
* 대용량 데이터 확인을 위한 디스크 탐색 시간 감소
* 적절한 단위의 블록 크기를 이용한 CPU 처리시간 증가



클라우드 저장공간을 이용하는 경우 HDFS를 이용하는 경우보다 속도가 느려집니다. 하지만 클라우드 저장공간을 이용하는 경우 영구적 데이터 보관 및 HDFS 관리비 절감에 따른 장점이 있습니다.



## 블록 작업 순서

블록 지역성 작업 우선 순위

1) 같은 노드에 있는 데이터

2) 같은 랙(Rack)의 노드에 있는 데이터

3) 다른 랙의 노드에 있는 데이터



## 블록 스캐너

데이터 노드는 주기적으로 블록 스캐너를 실행하여 블록의 체크섬을 확인하고 오류가 발생하면 수정합니다.



## 블록 캐싱

데이터 노드에 저장된 데이터 중 자주 읽는 블록은 블록 캐시(block cache)라는 데이터 노드의 메모리에 명시적으로 캐싱할 수 있습니다. 파일 단위로 캐싱할 수도 있어서 조인에 사용되는 데이터들을 등록하여 읽기 성능을 높일 수 있습니다.

```
$ hdfs cacheadmin

# pool 등록
$ hdfs cacheadmin -addPool pool1

# path 등록
$ hdfs cacheadmin -addDirective -path /user/hadoop/shs -pool pool1

# 캐쉬 확인
$ hdfs cacheadmin -listDirectives
```





# 2 Secondary Namenode

네임노드가 구동되고 나면, Edits 파일이 주기적으로 생성됩니다.  네임노드의 트랜잭션이 빈번하면, 빠른 속도로 Edits 파일이 생성됩니다. 네임노드의 디스크 부족 문제를 생성할 수 도 있고, 네임노드가 재구동 되는 시간을 느려지게 할 수도 있습니다.



세컨더리 네임노드는 Fsimage와 Edits 파일을 주기적으로 머지하여 최신 블록의 상태로 파일을 생성합니다. 파일을 머지하면서 Edits 파일을 삭제하기 때문에 디스크 부족 문제도 해결할 수 있습니다.

![](https://i.ibb.co/WzxbjD5/image.png)





---

**Reference**

https://wikidocs.net/37809

https://wikidocs.net/37810