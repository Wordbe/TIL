# MSA 002 - 이해

## 1 리액티브 선언

- 애플리케이션이 갖춰야 할 바람직한 속성들
-  2014년 요나스 보네르 (Jonas Boner) 등
- 리액티브 시스템 속성 (다양한 상황에 따라 빠르고 적절하게 반응하는 시스템)
  - 응답성 (Responsive)
    - 사용자에게 신뢰성 있는 응답을 빠르게 제공
  - 탄력성 (Resilient)
    - 장애 발생하더라도 전체가 고장나지 않고, 빠르게 복구
  - 유연성 (Elastic)
    - 시스템 사용량에 변화가 있어도 자원을 늘리거나 줄여서 균일한 응답성 제공
  - 메시지 기반 (Message Driven)
    - 비동기 메시지 전달을 통해 투명성, 느슨한 결합, 논블로킹 통신 지향



## 2 강결합 → 느슨한결합

## 3 MSA 외부, 내부 아키텍처

- 외부 : 마이크로서비스가 운영되는 환경 정의
  - 인프라, 플랫폼
- 내부 : 비즈니스 애플리케이션, API, 이벤트 발행, 데이터 저장 처리

## 4 MSA 패턴

크리스 리처드슨

- 인프라 패턴
- 애플리케이션 인프라 패턴
- 애플리케이션 패턴

MSA 구성요소, 패턴 유형

| 패턴유형          | 설명                                           |
| ----------------- | ---------------------------------------------- |
| 인프라 구성요소   | 마이크로서비스를 지탱하는 하부구조 인프라 구축 |
| 플랫폼 패턴       | 인프라 위에서 마이크로서비스 운영과 관리 지원  |
| 애플리케이션 패턴 | 마이크로서비스 애플리케이션 구성               |

### 1) 인프라 구성요소

- 퍼블릭 클라우드와 베어메탈, 프라이빗 클라우드
- VM 과 컨테이너
  - 가상머신과 컨테이너 차이
    - 게스트 OS를 사용하는 가상머신은 운영체제 패치 설치나 관련 라이브러리 설치 등 오버헤드가 지속적으로 발생
    - 따라서 MS 같은 작은 서비스를 패키지하고 배포하기에는 컨테이너 환경이 적합하다. 
      - 도커
      - 필요 라이브러리나 실행 파일을 여러 레이어 이미지로 추가하거나 변경 가능 

#### 컨테이너 오케스트레이션

- 컨테이너의 자동 배치, 복제, 장애 복구, 확장, 축소, 통신, 로드 밸런싱
- Docker swarm, Apache Mesos, Kubernetes

#### 클라우드 인프라 서비스

- IaaS(Infrastructure as a Service) : 가상머신, 스토리지, 네트워크 등 인프라는 필요한 만큼 적시에 제공한느 서비스
  - AWS EC2, Azure VM, GCP Compute Engine
- CaaS(Container as a Service) : 컨테이너 기반 가상화를 사용해 컨테이너 업로드, 구성, 실행, 확장, 중지할 수 있는 서비스, 다른 환경에서도 이식 가능한 컨테이너 기반 가상화 제공
  - Amazon EKS, AWS ECS, Azure AKS, Google GKE
- PaaS(Platform as a Service) : 애플리케이션을 곧바로 개발, 실행, 관리할 수 있는 플랫폼 환경을 제공하는 서비스 | IaaS 위에 미들웨어, 런타임까지 탑재
  - AWS Elastic Beanstalk, Azure Web App, Google App Engine, Heroku, Cloud Foundary

<br />

### 2) 플랫폼 패턴

#### DevOps 인프라구성

- 빌드, 테스트, 배포 자동화
- CI (Continuous Integration) : 자동으로 통합, 테스트하고 리포트로 남기는 활동
- CD (Continuous Delivery, Deployment) : 실행환경에 자동으로 배포하는 것

#### 빌드/배포 파이프라인 설계

- Infrastructure as a Code : 인프라 구성을 코드화, 대규모 인프라 관리, 공유, 재사용
- 레포지토리 → 빌드 & 단위 테스트 → 정적 분석 → 통합 테스트 → 배포 → 마이크로서비스

#### 마이크로서비스 운영관리

- 넷플릭스 OSS (Open Source Software)
  - API gateway, 라우팅 (Zuul)
  - 로드밸런싱 (Ribbon)
  - 모니터링 (Hystrix)
  - 서비스 디스커버리 (Eureka)
- Spring Cloud = Spring Boot + Netflix OSS

<br />

#### 1 서비스 레지스트리, 서비스 디스커버리 패턴

- Spring Cloud Eureka
- 마이크로서비스 서버 관리
- Config 서비스, 모니터링 서비스, 추적 서비스 정보
- k8s
  - 서비스 레지스트리, 디스커버리 기능을 자체기능인 Kubernetes DNS, Kubernetes Service 제공 

#### 2 API 게이트웨이 패턴 (서비스 단일 진입)

- Spring API Gateway
- 라우팅 (L4 하드웨어 장비로도 구성가능)
- 로드밸런싱
- 인증/인가 추적
- 장애 격리, 서비스 탐색
- 로깅
- 메트릭 (에러율, 평균/최고 지연시간, 호출빈도)
- 트레이싱 서비스 연계 (트래킹 ID 기록)
- 모니터링 서비스 연계한 장애 격리 (서킷 브레이커 패턴)
- k8s
  - Kubernetes Service, Ingress Resource

#### 3 BFF 패턴

- Backend For Frontend
- 게이트 웨이 진입점을 프론트 기종에 맞게 여러개로

![](https://i.ibb.co/ggS4b3Y/image.png)

#### 4 설정 정보 관리, 외부 구성 저장소 패턴

- Spring Cloud Config

#### 5 인증/인가 패턴

- 중앙 집중식 세션 관리
  - 중앙 공유 저장소
  - Redis, Memcached
- 클라이언트 토큰
  - JWT

#### 6 서킷 브레이커 패턴 (장애 및 실패 처리)

- 장애 발생시 연결 끊고 (open), fallback 메소드 실행

#### 7 모니터링과 추적 패턴

- Spring Cloud Hystrix
- 분산 트레이싱 서비스
  - 각 서비스 트랜잭션의 호출을 추적하여 마이크로서비스 운영
  - Zipkin
    - API 간 호출 시 반응 시간, 지연 구간, 호출 빈도

#### 8 중앙화된 로그 집계 패턴

- 이벤트 스트림
  - 로그는 시작과 끝이 고정된 것이 아닌 서비스가 실행되는 동안 계속 흐르는 흐름
  - 서비스는 스트림의 전달이나 저장에 절대 관여하지 않는다.
  - ELK 스택

<br />

<br />



#### MSA 기술 변화 흐름

![](https://i.ibb.co/bsrf428/image.png)

- 1.0 : Spring Cloud, Netflix OSS, AWS
- 2.0 : OpenShift, Kubernetes
- 3.0 : Kubernetes, Istio

#### 11 서비스 메시 패턴

- Service Mesh : MSA 문제 영역 해결 기능 (서비스 탐색, 서킷 브레이크, 추적, 로드 밸런싱 등)을 비즈니스 로직과 분리 네트워크 인프라 계층에서 수행
  - 인프라 레이어
  - 서비스 간 통신을 처리
  - 구글의 Istio
  - 애플리케이션이 배포되는 컨테이너에 완전 격리되어 별도의 컨테이너로 배포되는 사이드카 패턴 적용하여
    - 서비스 디스커버리, 라우팅, 로드 밸런싱, 모니터링, 보안, 트레이싱 기능 제공

![](https://i.ibb.co/6PvgNWr/image.png)

- Istio 는 Spring Cloud 에서 제공했던 대부분 기능 지원 + 차별점
  - 주요 기능
    - 트래픽 관리 : 동적 라우팅, 로드 밸런싱
    - 보안 : TLS (보안통신채널), 인증/인가/암호화
    - 관측성(Observability) : 메트릭, 분산트레이싱, 로깅
  - 차별점
    - 애플리케이션 코드 변경 거의 없다.
    - 이스티오는 사이드카로 격리된다. yaml 설정 파일로 정의
    - 폴리글랏 애플리케이션 지원. 스프링 클라우드는 자바만 지원
    - k8s 와 완벽하게 통합된 환경 지원

<br />

### 3) 애플리케이션 패턴



#### 1 UI 컴포짓 패턴 or마이크로 프론트엔드

- 프론트엔드 역시 재배포시 전체가 함께 빌드됨
- 프론트엔드도 마이크로서비스처럼 기능별 분리

#### 2 마이크로서비스 통신 패턴

- 동기

  ![](https://i.ibb.co/SyZ9Szj/image.png)

  - 장애가 연쇄적으로 발생할 수 있다.
  - 서비스 간 의존관계가 높다.

- 비동기

  ![](https://i.ibb.co/zbbmdqn/image.png)

  - 메시지 기반 비동기 호출
  - 동기 처럼 완결성을 보장할 수는 없다.
  - 카프카, RabbitMQ 등 메시지 브로커 활용
  - 클라우드 벤더에서 완전관리형으로 제공
    - AWS SQS(Simple Queue Service) : 마이크로서비스, 분산 시스템, 서버리스 애플리케이션을 쉽게 분리, 확장할 수 있도록 지원하는 메시지 대기열 서비스
    - AWS SNS(Simple Notification Service) : pub/sub 메시징, SMS, 이메일 및 모바일 푸시 알림 제공 서비스
    - Azure Event Hub, Azure Event Grid

  > 이벤트 기반 아키텍처 (Event Driven Architecture)
  >
  > - 비동기 통신 방식 이용 느슨한 연계 지향
  > - 발행자가 이벤트 생성, 발생
  > - 구독자가 이벤트 구독
  > - 이벤트는 ‘상태의 변화’
  > - 이벤트 기반 마이크로서비스 도입하면 발신자와 수신자를 장소와 시간에서 쉽게 분리 가능, 느슨한 결합으로 확장성, 탄력성 이점

  

  <br />

  

#### 3 저장소 분리 패턴

- 데이터 중심 애플리케이션
  - 관계형 데이터베이스 벤더에 구속, 복잡, 유지보수가 어려움
  - 성능 문제 발생시 SQL 튜닝이나 저장소 스케일업에 의존할 수 밖에 없음
- 각 마이크로서비스는 자신의 데이터를 직접 소유,
  - 노출하지 않고, 공개 API를 통해서만 접근 (정보 은닉)
  - 폴리글랏 저장소 가능
  - 데이터를 통한 변경의 파급 효과(영향도) 줄여 서비스를 독립적으로 만든다.

**하지만, 데이터 일관성 보장은?**



#### 4 분산 트랜잭션 처리 패턴

- **사가(Saga) 패턴**
  - 영어에서 Saga 는 스칸디나비아 역사의 긴 이야기. 길고 복잡한 일련의 이벤트 등을 말한다.
- 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴이다.
- 여러 분산 서비스를 하나의 트랜잭션으로 묶지 않고, **로컬 트랜잭션과 보상 트랜잭션**으로 비즈니스 및 데이터의 정합성을 맞춘다.
- 보상 트랜잭션은 트랜잭션 서비스 실패시 앞선 다른 트랜잭션을 롤백

![](https://i.ibb.co/dbdnmYz/image.png)

- 결과적 일관성 (Eventual Consistency)

  ![](https://i.ibb.co/NrRWp0V/image.png)

  - 고가용성 극대화
  - 각 서비스의 트랜잭션은 독립적이고, 트랜잭션이 성공했을 때 상태 변경 이벤트를 발행하여 이벤트를 구독한 다른 서비스의 로컬 트랜잭션이 작동되게 한다.
    1. 가주문 생성, 가주문됨 이벤트 발행, 주문은 로컬 트랜잭션이고 끊임없이 받을 수 있어서 주문이 몰릴 경우 주문 서비스만 확장해서 가용성을 높일 수 있다.
    2. 가주문됨 이벤트는 메시지 브로커에 비동기로 전송
    3. 결제서비스는 가주문됨 이벤트 구독하여 로컬 트랜잭션 수행후 결제처리됨 이벤트 발행
    4. 이메일서비스는 결제처리됨 이벤트를 구독하여 주문결제완료 이메일을 사용자에게 발송
    5. 주문서비스는 결제처리이벤트를 구독하여 가주문으로 처리했던 주문을 최종승인. 최종주문완료됨 이벤트 발행
    6. 이메일서비스는 최종주문완료됨 이벤트를 구독하여 최종적으로 주문이 완료됐다는 이메일을 사용자에게 발송
    7. 각 서비스는 실패 이벤트 발행해서 다른서비스가 비즈니스 정합성을 맞출 수 있게 한다.
    8. 메시지큐에 쌓이는 이벤트들은 모니터링 서비스와 연계해 모니터링하고 추적해서 전체 비즈니스 정합성 여부를 관리자가 확인
  - 이벤트기반 아키텍처 + 메시지 브로커 + 사가 패턴 → 최종 일관성 보장, 비즈니스와 시스템 가용성 극대화

  <br />

  #### 5 CQRS 패턴 (읽기와 쓰기 분리)

  - Command Query Responsibility Segregation, 명령 조회 책임 분리
  - 스케일 아웃에서 각 서비스 트랜잭션은 데이터 읽기/수정 작업으로 인한 리소스 교착상태(dead lock)가 발생할 수 있다.
  - 쓰기전략과 조회전략을 분리하면 시스템 부하를 줄일고, 조회 대기 시간을 줄이는 이점을 누린다.

  ![](https://i.ibb.co/RQBSwz7/image.png)

- CUD : 쓰기에 최적화된 RDB + 업무규칙 표현하기좋은 자바
  - 명령서비스는 DB에 데이터를쓰면서, 저장한 내역이 담긴 이벤트 발행하여 메시지 브로커에게 전달
  - 조회서비스는 메시지브로커 이벤트를 구독하고 있다가, 데이터를 가져와 최신 상태로 동기화 (평소에는 수십~수백ms, 길어도 2~3초)
- R : 조회성능이 높은 몽고DB, Elasticsearch 등 NoSQL + 간단하게 조회할 수 있는 Node.js
  - 조회는 사용량이 많으므로 스케일 아웃



#### 5 API 조합과 CQRS

- 마이크로서비스별 저장소가 격리되있고, 여러 데이터를 연계하여 하나의 서비스로 제공하고자 함

  1) API 조합

  - 상위 서비스가 하위 서비스에 의존하는 결과 → 변경에 취약

  2) CQRS

  ![](https://i.ibb.co/2cx7jB2/image.png)

  - 주문 이력 마이크로서비스는 이벤트를 구독하고 있다가 자신의 서비스 저장소에 기록한다.
  - 다른 서비스와 데이터 일관성을맞춘다. 의존성도 느슨해진다.

#### 6 쓰기 최적화 : 이벤트 소싱 패턴

![](https://i.ibb.co/HTNf0xv/image.png)

![](https://i.ibb.co/grHwBzS/image.png)

- 사가패턴, CQRS패턴 둘 다 저장소에 저장하는 것과 메시지를 보내는 것이 원자성을 지녀야 한다.
- 저장 및 메시지 발행의 원자성을 보장하고 성능을 최적화하는 방법?
  - **이벤트 소싱 (Event Sourcing) : 트랜잭션 자체를 저장**
    - Axon, Eventuate
  - 객체 상태를 데이터 모델에 맞춰 계산하지 않고, 상태 트랜잭션 자체를 저장한다.
  - 현시점 상태가 필요할 때 상태의 출발점부터 모든 기록된 상태 변경 트랜잭션을 순차적으로 계산한다.
    - 매일 자정에 상태를 계산해 스냅샷으로 저장하는것도 방법
  - 이벤트 저장소에 대한 CRUD 대신 CR(입력/조회) 만 하면 된다. 
    - 동시 업데이트 및 교착상태가 발생하지 않는다.
    - 동시성 이슈, 정합성 이슈로부터 비교적 자유롭다.



