# MSA 003 - 프로세스 간 통신

- 프로세스 간 통신 = IPC, Inter-Process Communication



# 1 MSA IPC

## 1. 상호작용 스타일

클라이언트/서비스 상호 작용 스타일

- 일대일/일대다
- 동기/비동기

일대일

- 요청/응답 : 결합도 강함
- 비동기 요청/응답 : 대기 중 non-blocking, 서비스는 오랫동안 응답하지 않을 수 있다.
- 단방향 알림
  - 클라이언트가 서버로 요청만 보내고, 응답은 받지 않음

일대다

- 발행/구독
  - 클라이언트는 알림 메시지 발행하고, 여기에 관심 있는 0개 이상의 서비가 메시지를 소비
- 발행/비동기 응답
  - 클라이언트는 요청 메시지를 발행하고, 주어진 시간 동안 관련 서비스가 응답하기를 기다린다.



## 2 API 정의

## 3 API 발전시키기

- 시멘틱 버저닝 명세
  - MAJOR
  - MINOR
  - PATCH
- 하위 호환되는 소규모 변경
- 중대한 대규모 변경
  - `/v1/`, `/v2/`
  - HTTP Content Negotiation 이용해서 MIME 타입 내부에 버전번호를 끼워넣는 방법도 있다.
- 텍스트 메시지 포맷
  - JSON, XML
    - self describing
- 이진 메시지 포맷
  - 포로토콜 버퍼
  - 아브로 (avro)

<br />

# 2 동기 RPI 패턴 응용 통신

- RPI (Remote Procedure Invocation, 원격 프로시저 호출) 패턴

- 클라이언트는 블로킹 또는 리액티브한 논블로킹일 수 있다. 둘 다 응답이 제 때 도착하리라 가정한다.

## 1 동기 RPI 패턴 : REST

- REST API
  - 인터페이스 정의 언어로 스웨거, 오픈API명세가 있다.

단점

- 요청 한번으로 많은 리소스를 가져오기 어렵다.
  - 이 때문에 GraphQL, Netflix Falcor 등 대체 기술이 등장
- 작업을 HTTP 메소드(동사)에 매핑하기 어렵다.
  - 주문 취소/변경 등 여러 업데이트가 있을 수 있다.
    - 이 부분은 같은 메소드로 하되 하위 리소스(sub-resource)를 정의하여 해결한다.
    - POST `/orders/{orderId}/cancel`, POST `/orders/{orderId}/revise`
  - POST 를 제외하고는 멱등성을 만족하도록.

### REST 장단점

장점

- 단순하고 익숙
- 포스트맨, 브라우저, curl 로 테스트 가능
- 요청/응답 스타일의 통신을 직접 지원
- HTTP 는 방화벽 친화적
- 중간 브로커가 필요하지 않으므로 시스템 아키텍처가 단순

단점

- 요청/응답 스타일 통신만 지원
- 가용성이 떨어진다. 중간에 브로커가 없으므로 클라이언트/서버가 직접 통신하여 교환이 일어나는 동안 둘 다 실행중이어야 한다.
- 서비스 인스턴스들의 위치(URL)를 클라이언트가 알고 있어야 한다.
- 요청 한 번으로 여러 리소스를 가져오기 어렵다.
- 다중 업데이트 작업을 HTTP 동사에 매핑하기 어려울 때가 많다.

## 2 동기 RPI 패턴 : gPRC

- 동기 통신
- 이진 메시지 기반 프로토콜이므로 서비스를 API 우선 설계할 수 밖에 없다.
- 프로토콜 버퍼 기반의 IDL로 정의
- 클라이언트/서버는 프로토콜 버퍼 포맷의 이진 메시지를 HTTP/2 를 통해 교환
- 단순 요청/응답 PRC
- 스트리밍 RPC 지원, 양방향 지원

장점

- 다양한 업데이트 작업이 포함된 API 설계가 쉽다.
- 큰 메시지를 교환할 때 컴팩트하고 효율적인 IPC
- 양방향 스트리밍 덕분에 RPI, 메시징 두 가지 통신 방식이 모두 가능
- 다양한 언어로 작성된 클라이언트/서버 간 연동 가능

단점

- javascript 클라이언트가 하는일이 REST/JSON 보다 많다.
- 구형 방화벽은 HTTP/2를 지원하지 않는다.

## 3 부분 실패 처리 : Circuit Breaker Pattern (회로 차단기 패턴)

- 서킷브레이커 : 연속 실패 횟수가 임계치를 초과하면 일정 시간 동안 호출을 즉시 거부하는 RPI 프록시
- 클라이언트는 응답 대기 중 블로킹 되므로, 서비스 실패는 클라이언트로 거슬러 올라가서 전체 시스템 중단을 초래할 수도 있다.
- 서킷브레이커 프록시 설계
- 원격 서비스가 실패하면 어떻게 조치할지 결정

![](https://i.ibb.co/sjbLWxV/image.png)

### 프록시 설계

- 네트워크 타임아웃 : 응답 대기 중 무한정 블로킹 보다는 항상 타임아웃을 걸어둔다.
- 미처리 요청 (outstanding request) : 클라이언트가 특정 서비스에 요청 가능한 미처리 요청 최대 개수를 설정한다. 초과시 즉시 실패 처리
- 서킷브레이커 패턴 : 성공/실패 요청 개수 모니터링 후, 에러율이 임계치 초과하면 그 이후 처리는 실패 처리. 타임아웃 시간 이후 클라이언트가 재시도해서 성공하면 회로차단기는 다시 닫힌다
  - Netflix Hystrix
  - Resilience4J

### 불능 서비스 복구

- 대체값(fallback value) 반환 :부분 실패 시 미리정해진 기본값 / 캐시된 응답 등 반환
- 또는 에러를 반환한다.

<br />

## 4 서비스 디스커버리

### 애플리케이션 수준 서비스 디스커버리 적용

![](https://i.ibb.co/NVrWkPJ/image.png)

- Netflix Eureka
- Spring Cloud Eureka

### 플랫폼에 내장된 서비스 디스커버리 적용

- 도커, 쿠버네티스
- DNS명, 가상 IP주소(VIP주소)
- 서드파티 등록
- 서버쪽 디스커버리
- 쿠버네티스는 쿠버네티스로 배포한 서비스에서만 서비스 디스커버리가 적용된다.
- 서비스 디스커버리 관련 코드는 클라이언트/서비스 어느쪽도 없기 때문에 편하게 적용 가능
- 플랫폼에서 제공되는 서비스 디스커버리 사용을 권장

<br />

# 3 비동기 메시징 패턴 응용 통신

### 메시지

- 헤더
- 바디

### 메시지 채널

- 점대점 채널
  - 채널을 읽는 컨슈머 중 하나만 지정하여 메시지 전달
  - 커맨드 메시지
- 발행-구독 채널
  - 같은 채널을 바라보는 모든 컨슈머에게 메시지 전달
  - 이벤트 메시지

## 메시징 상호작용 스타일 구현

- 클라이언트는 서비스가 어디로 응답 메시지를 보내야 하는지 알려주고, 이렇게 받은 응답 메시지는 요청과 짝이 맞는 것만 받는다.

![](https://i.ibb.co/L8Lwkkf/image.png)

















