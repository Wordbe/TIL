# MSA 003 - 프로세스 간 통신

- 프로세스 간 통신 = IPC, Inter-Process Communication



# 1 MSA IPC

## 1. 상호작용 스타일

클라이언트/서비스 상호 작용 스타일

- 일대일/일대다
- 동기/비동기

일대일

- 요청/응답 : 결합도 강함
- 비동기 요청/응답 : 대기 중 non-blocking, 서비스는 오랫동안 응답하지 않을 수 있다.
- 단방향 알림
  - 클라이언트가 서버로 요청만 보내고, 응답은 받지 않음

일대다

- 발행/구독
  - 클라이언트는 알림 메시지 발행하고, 여기에 관심 있는 0개 이상의 서비가 메시지를 소비
- 발행/비동기 응답
  - 클라이언트는 요청 메시지를 발행하고, 주어진 시간 동안 관련 서비스가 응답하기를 기다린다.



## 2 API 정의

## 3 API 발전시키기

- 시멘틱 버저닝 명세
  - MAJOR
  - MINOR
  - PATCH
- 하위 호환되는 소규모 변경
- 중대한 대규모 변경
  - `/v1/`, `/v2/`
  - HTTP Content Negotiation 이용해서 MIME 타입 내부에 버전번호를 끼워넣는 방법도 있다.
- 텍스트 메시지 포맷
  - JSON, XML
    - self describing
- 이진 메시지 포맷
  - 포로토콜 버퍼
  - 아브로 (avro)

<br />

# 2 동기 RPI 패턴 응용 통신

- RPI (Remote Procedure Invocation, 원격 프로시저 호출) 패턴

- 클라이언트는 블로킹 또는 리액티브한 논블로킹일 수 있다. 둘 다 응답이 제 때 도착하리라 가정한다.

## 1 동기 RPI 패턴 : REST

- REST API
  - 인터페이스 정의 언어로 스웨거, 오픈API명세가 있다.

단점

- 요청 한번으로 많은 리소스를 가져오기 어렵다.
  - 이 때문에 GraphQL, Netflix Falcor 등 대체 기술이 등장
- 작업을 HTTP 메소드(동사)에 매핑하기 어렵다.
  - 주문 취소/변경 등 여러 업데이트가 있을 수 있다.
    - 이 부분은 같은 메소드로 하되 하위 리소스(sub-resource)를 정의하여 해결한다.
    - POST `/orders/{orderId}/cancel`, POST `/orders/{orderId}/revise`
  - POST 를 제외하고는 멱등성을 만족하도록.

### REST 장단점

장점

- 단순하고 익숙
- 포스트맨, 브라우저, curl 로 테스트 가능
- 요청/응답 스타일의 통신을 직접 지원
- HTTP 는 방화벽 친화적
- 중간 브로커가 필요하지 않으므로 시스템 아키텍처가 단순

단점

- 요청/응답 스타일 통신만 지원
- 가용성이 떨어진다. 중간에 브로커가 없으므로 클라이언트/서버가 직접 통신하여 교환이 일어나는 동안 둘 다 실행중이어야 한다.
- 서비스 인스턴스들의 위치(URL)를 클라이언트가 알고 있어야 한다.
- 요청 한 번으로 여러 리소스를 가져오기 어렵다.
- 다중 업데이트 작업을 HTTP 동사에 매핑하기 어려울 때가 많다.

## 2 동기 RPI 패턴 : gPRC

- 동기 통신
- 이진 메시지 기반 프로토콜이므로 서비스를 API 우선 설계할 수 밖에 없다.
- 프로토콜 버퍼 기반의 IDL로 정의
- 클라이언트/서버는 프로토콜 버퍼 포맷의 이진 메시지를 HTTP/2 를 통해 교환
- 단순 요청/응답 PRC
- 스트리밍 RPC 지원, 양방향 지원

장점

- 다양한 업데이트 작업이 포함된 API 설계가 쉽다.
- 큰 메시지를 교환할 때 컴팩트하고 효율적인 IPC
- 양방향 스트리밍 덕분에 RPI, 메시징 두 가지 통신 방식이 모두 가능
- 다양한 언어로 작성된 클라이언트/서버 간 연동 가능

단점

- javascript 클라이언트가 하는일이 REST/JSON 보다 많다.
- 구형 방화벽은 HTTP/2를 지원하지 않는다.

## 3 부분 실패 처리 : Circuit Breaker Pattern (회로 차단기 패턴)

- 서킷브레이커 : 연속 실패 횟수가 임계치를 초과하면 일정 시간 동안 호출을 즉시 거부하는 RPI 프록시
- 클라이언트는 응답 대기 중 블로킹 되므로, 서비스 실패는 클라이언트로 거슬러 올라가서 전체 시스템 중단을 초래할 수도 있다.
- 서킷브레이커 프록시 설계
- 원격 서비스가 실패하면 어떻게 조치할지 결정

![](https://i.ibb.co/sjbLWxV/image.png)

### 프록시 설계

- 네트워크 타임아웃 : 응답 대기 중 무한정 블로킹 보다는 항상 타임아웃을 걸어둔다.
- 미처리 요청 (outstanding request) : 클라이언트가 특정 서비스에 요청 가능한 미처리 요청 최대 개수를 설정한다. 초과시 즉시 실패 처리
- 서킷브레이커 패턴 : 성공/실패 요청 개수 모니터링 후, 에러율이 임계치 초과하면 그 이후 처리는 실패 처리. 타임아웃 시간 이후 클라이언트가 재시도해서 성공하면 회로차단기는 다시 닫힌다
  - Netflix Hystrix
  - Resilience4J

### 불능 서비스 복구

- 대체값(fallback value) 반환 :부분 실패 시 미리정해진 기본값 / 캐시된 응답 등 반환
- 또는 에러를 반환한다.

<br />

## 4 서비스 디스커버리

### 애플리케이션 수준 서비스 디스커버리 적용

![](https://i.ibb.co/NVrWkPJ/image.png)

- Netflix Eureka
- Spring Cloud Eureka

### 플랫폼에 내장된 서비스 디스커버리 적용

- 도커, 쿠버네티스
- DNS명, 가상 IP주소(VIP주소)
- 서드파티 등록
- 서버쪽 디스커버리
- 쿠버네티스는 쿠버네티스로 배포한 서비스에서만 서비스 디스커버리가 적용된다.
- 서비스 디스커버리 관련 코드는 클라이언트/서비스 어느쪽도 없기 때문에 편하게 적용 가능
- 플랫폼에서 제공되는 서비스 디스커버리 사용을 권장

<br />

# 3 비동기 메시징 패턴 응용 통신

### 메시지

- 헤더
- 바디

### 메시지 채널

- 점대점 채널
  - 채널을 읽는 컨슈머 중 하나만 지정하여 메시지 전달
  - 커맨드 메시지
- 발행-구독 채널
  - 같은 채널을 바라보는 모든 컨슈머에게 메시지 전달
  - 이벤트 메시지

## 2 메시징 상호작용 스타일 구현

- 클라이언트는 서비스가 어디로 응답 메시지를 보내야 하는지 알려주고, 이렇게 받은 응답 메시지는 요청과 짝이 맞는 것만 받는다.

![](https://i.ibb.co/L8Lwkkf/image.png)

### 단방향 알림

- one-way notification
- 클라이언트가 메시지를 보내면, 서빗는 이 채널을 구독해서 메시지 처리하고 응답은 반환하지 않는다.

### 발행/구독

- 서비스는 이벤트를 발행하여 채널에 쓰고, 다른 서비스는 관심 있는 도메인 객체의 이벤트 채널을 구독한다.

### 발행/비동기 응답

- 컨슈머는 `CorrelationId` 가 포함된 응답 메시지를 지정된 응답 채널에 포함하기 까지 한다.

## 3 메시징 기반 서비스의 API 명세

비동기 API 명세

- 메시지 채널명 : 정해진 표준이 없음
- 메시지 타입 : 정해진 표준이 없음
- 메시지 포맷 : JSON, XML, 프로토콜 버퍼

### 비동기 작업 문서화

두 가지 중 하나

- 요청/비동기 응답 스타일 API
- 단방향 알림 스타일 APII

### 발행 이벤트 문서화

- 발행/구독

## 4 메시지 브로커

- Kafka
- AWS Kinesis, AWS SQS

장점

- 느슨한 결합
- 메시지 버퍼링
- 유연한 통신
- 명시적 IPC

단점

- 성능 병목 가능성
- 단일 장애점 가능성
- 운영 복잡도 부가

## 5 수신자 경합과 메시지 순서 유지

![](https://i.ibb.co/PFkXQFd/image.png)

- 채널은 샤드들로 구성된다.
- 프로듀서는 메시지 헤더에 샤드키를 지정한다. 메시지 브로커는 메시지를 샤드키별로 샤드/파티션에 배정한다. (예. 샤드키 해시값 % 샤드 개수)
- 브로커는 여러 컨슈머 인스턴스를 묶어 마치 동일한 논리 컨슈머로 취급한다. (컨슈머 그룹) 메시지 브로커는 각 샤드를 하나의 컨슈머 그룹에 배정한다. 컨슈머 그룹이 시동/종료하면 샤드를 재배정한다.

## 6 중복 메시지 처리

- 멱등한 (idempotent) 메시지 핸들러를 작성해야 한다. (같은 작업을할 때 같은 결과를 반환)
- 메시지를 추적하고 중복을 솎아내야 한다.

### 멱등한 메시지 핸들러 작성

- 동일한 값을 입력하여 반복 호출해도 부수 효과가 없을 때 멱등하다라고 말한다.
- 애플리케이션의 메시지 처리 로직이 멱등하면 중복 메시지는 전혀 해롭지 않다.
- 그러나 멱등한 로직은 실제 별로 없다.

### 메시지 추적과 중복 메시지 솎아 내기

- 소비자 신용카드를 승인하는 메시지 핸들러.
  - 주문 별로 정확히 1회 신용카드를 승인해야 한다.
  - 중복 되면 심각
  - 따라서 메시지 핸들러가 반드시 중복 메시지를 걸러내야 한다.
- 컨슈머가 메시지 ID 를 이용해서, 메시지 처리 여부를 추적하면서 중복 메시지를 솎아 낸다.
  - 예를 들면 컨슈머가 소비하는 메시지 ID를 무조건 DB 테이블에 저장한다.
    - 중복된 메시지라면 `INSERT` 쿼리가 실패하고 조용히 무시된다.

## 7 트랜잭셔널 메시징

- 분산 트랜잭션 지원하지 않는 DB가 많다. (카프카도 지원하지 않는다.)

### DB 테이블을 메시지 큐로 활용

- RDBMS 기반 애플리케이션이라면 DB 테이블을 임시 메시지 큐로 사용 (트랜잭셔널 아웃박스 패턴)
  - 비즈닉스 CUD 로직 트랜잭션의 일부로 `OUTBOX` 테이블에 메시지 삽입
- 메시지 릴레이는 `OUTBOX` 테이블 읽어 브로커에 메시지를 발행한다.

메시지를 DB에서 메시지 브로커로 옮기는 방법

### 1) 이벤트 발행: 폴링 발행기 패턴

```sql
# 미발행 메시지를 주기적으로조회
SELECT * FROM OUTBOX
ORDER BY ... ASC

# 나중에 메시지 삭제
BEGIN
DELETE FROM OUTBOX WHERE ID in ...
COMMIT
```

### 2) 이벤트 발행: 트랜잭션 로그 테일링 패턴

- 애플리케이션에서 커밋된 업데이트는 각 DB 트랜잭션 로그 항목(log entry)에 남는다.
- 트랜잭션 로그 마이너로 트랜잭션 로그를 읽어 변경분을 하나씩 브로커에 발행한다.
  - AWS DynamoDB 스트림즈는 최근 24시간 동안 테이블에 적용된 변경분을 시간 순으로 정렬한 데이터를 가진다. 애플리케이션은 스트림에서 변경분을 읽어 이벤트로 발행할 수 있다.

## 8 메시징 라이브러리/프레임워크

- Eventuate Tram
  - 필자가 개발한 오픈소스 트랜잭션 메시징 라이브러리
  - 중복 메시지 감지
  - 기초 메시징
  - 도메인 이벤트 발행
  - 커맨드/응답 메시징

<br />

# 4 비동기 메시징으로 가용성 개선

## 1 동기 통신으로 인한 가용성 저하

## 2 동기 상호 통신 작용 제거

### 비동기 상호 작용 스타일

![](https://i.ibb.co/XXNq4YC/image.png)

### 데이터 복제

- 소비자/음식점 서비스에서 데이터가 변경될때마다 이벤트를 발행하고, 주문서비스는 이 이벤트를 구독하여 자기편 레플리카를 업데이트

### 응답 반환 후 마무리

요청 처리 도중 동기 통신을 제거하려면 요청을 다음과 같이 처리

1. 로컬에서 가용한 데이터만 갖고 요청 검증
2. 메시지를 `OUTBOX` 테이블에 삽입
3. 클라이언트에 응답 반환

![](https://i.ibb.co/FKLWDXy/image.png)





















