# MSA 006 - 이벤트 소싱

- 이벤트 소싱은 애그리거트를 일련의 이벤트 형태로 바로 저장한다.
- 이벤트는 각 애그리거트의 상태 변화를 나타낸다.
- 애플리케이션은 이벤트를 재연(replay)하여 애그리거트의 현재 상태를 재생성한다.
  - 애그리거트 이력이 보존되므로 감사/통제 용도의 가치가 있다.
  - 이벤트 저장소를 쿼리하기 쉽지 않아 CQRS 패턴을 적용해야 한다.



# 1 이벤트 소싱

## 1 기존 영속화 문제점

- 객체 관계 매핑의 부정합
- 애그리거트 이력이 없음
- 감사 로깅 구현이 어렵고, 에러가 잘 발생한다.
- 이벤트 발행 로직이 비즈니스 로직에 추가된다.

## 2 이벤트 소싱 개요

- 이벤트를 이용하여 애그리거트 저장

- 애그리거트 생성/수정시 애플리케이션은 도메인 이벤트를 테이블에 삽입

  ![](https://i.ibb.co/fpTrxTy/image.png)

- 재연

  1. 애그리거트 이벤트를 load
  2. 기본 생성자를 호출하여 애그리거트 인스턴스를 생성한다.
  3. 이벤트를 하나씩 순회하며 apply 호출

```java
Class aggregateClass = ...;
Aggregate aggregate = aggregateClass.newInstance();
for (Event event: events) {
    aggregate = aggregate.applyEvent(event);
}
```



### 이벤트는 곧 상태변화

### 애그리거트 메서드의 관심사는 오직 이벤트

## 3 동시 업데이트: 낙관적 잠금

- 한 트랜잭션이 다른 트랜잭션의 변경을 덮어쓰지 못하게 낙관적 잠금 (버전 컬럼 사용) 하여 처리

```sql
UPDATE aggregate_root_table
SET version = version + 1
WHERE version = <원본 버전>
```

- 동시 진행되는 트랜잭션에서 첫번째 트랜잭션만 유효하게 데이터가 반영된다.



## 4 이벤트 소싱과 이벤트 발행

### 이벤트 발행: 폴링

- 후행 트랜잭션이 커밋된다.

- 해결방법은 EVENTS 테이블에 이벤트 발행 여부를 추적할 수 있는 컬럼을 추가하는 것

  ```sql
  # 1. 미발행 이벤트 조회
  SELECT * FROM events WHERE published = 0 ORDER BY event_id ASC
  # 2. 메시지 브로커에 이벤트 발행
  # 3. 이벤트가 발행된 것으로 표시
  UPDATE events SET published = 1 WHERE event_id = ?
  ```

### 이벤트 발행: 트랜잭션 로그 테일링

- 이벤트 발행을 확실히 보장하면서 성능/확장성 우수



## 5 스냅샷으로 성능 개선

- 이벤트 수가 많은 애그리거트는 일일이 로드/폴드하기가 어렵다.
- 대신 주기적으로 애그리거트 상태의 스냅샷을 저장한다.
- 스냅샷 버전이 N이면, N + 1 이후에 발생한 이벤트만 가져오면 애그리거트 상태를 되살릴 수 있다.



## 6 멱등한 메시지 처리

- 메시지 브로커가 동일한 메시지를 여러 번 전송할 가능성이 있으므로 메시지 컨슈머는 멱등하게 개발해야 한다.
- 동일한 메시지를 여러 번 호출해도 안전하다면 멱등한 것이다.

### RDBMS 이벤트 저장소 사용

- 메시지 id는 `PROCESSED_MESSAGES` 테이블에, 이벤트는 `EVENTS` 테이블에 삽입하는 트랜잭션의 일부로 삽입한다.

### NoSQL 이벤트 저장소 사용

- 메시지 컨슈머가 메시지 처리 도중 생성된 메시지 ID를 저장한다.
- 항상 이벤트를 발행한다.



## 7 도메인 이벤트 발전시키기

### 이벤트 스키마

- 하나 이상의 애그리거트
- 각 애그리거트가 발생시키는 이벤트 정의
- 이벤트 구조 정의

### 업캐스팅을 통한 스키마 변화 관리

- 업캐스터가 개별 이벤트를 구버전에서 신버전으로 업데이트하므로, 애플리케이션 코드는 현재 이벤트 스키마를 잘 처리하기만 하면 된다.



## 8 이벤트 소싱 장점

### 도메인 이벤트를 확실하게 발행

### 애그리거트 이력 보존

### 객체 테이블(O/R) 임피던스 불일치 문제 방지

### 개발자에게 타임 머신 제공



## 9 이벤트 소싱 단점

### 새로운 프로그래밍 모델을 배울 때 시간 소요

### 메시징 기반 애플리케이션은 복잡

### 이벤트를 발전시키기 어렵다.

### 데이터 삭제가 어렵다.

### 이벤트 저장소를 쿼리하기 어렵다.







---

# 2 이벤트 저장소 구현

![](https://i.ibb.co/Yfyk6P2/image.png)

제품

- Event Store
- Lagom
- Axon
- Eventuate

## 1 이벤추에이트 로컬 이벤트 저장소의 작동 원리

### 이벤트 DB 스키마

- events : 이벤트 저장
- entities : 엔티티 당 로우 하나
- snapshots : 스냅샷 저장

## 2 자바용 이벤추에이트 클라이언트



# 3 사가와 이벤트 소싱을 접목

## 1 코레오그래피 사가 구현: 이벤트 소싱

## 2 오케스트레이션 사가 생성

- 사가 오케스트레이터 작성 : NoSQL 이벤트 저장소 사용

## 3 이벤트 소싱 기반의 사가 참여자 구현

- 커맨드 메시지를 멱등하게 처리
- 응답 메시지를 원자적으로 전송

## 4 사가 오케스트레이터 구현: 이벤트 소싱







