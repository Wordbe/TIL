## 21. Custom Hook 만들기

컴포넌트를 만들다보면, 반복되는 로직이 자주 발생합니다.

이러한 상황에서는 커스텀 Hooks를 만들어서 함수를 재사용하는 것이 좋습니다.



src > hooks > useInputs.js 를 만들어봅시다.

```javascript
import { useState, useCallback } from 'react';

function useInputs(initialForm) {
  const [form, setForm] = useState(initialForm);
  // change
  const onChange = useCallback(e => {
    const { name, value } = e.target;
    setForm(form => ({ ...form, [name]: value }));
  }, []);
  const reset = useCallback(() => setForm(initialForm), [initialForm]);
  return [form, onChange, reset];
}

export default useInputs;
```



이제 App.js 에서 custom hook을 사용해봅시다.

`useReducer`쪽에서 사용하는 `inputs`를 없애고 이에 관련된 작업을 `useInputs`로 대체해 주어야 합니다.

또한 새로운 항목값을 추가할 때는 input 값을 초기화 해야 하므로 데이터 등록 후 `reset()`을 호출해주면 됩니다.



App.js 수정

```javascript
...
const [{ username, email }, onChange, reset] = useInputs({
    username: '',
    email: ''
});

// 기존 username, email 삭제

...
const onCreate = useCallback(() => {
    dispatch({
      type: 'CREATE_USER',
      user: {
        id: nextId.current,
        username,
        email
      }
    });
    reset();
    nextId.current += 1;
  }, [username, email, reset]);

...
```



**+추가**

`useInputs` 커스텀 Hook을 `useReducer`를 사용해서 구현할 수 있습니다.





<details markdown="1">
    <summary>접기/펼치기</summary>
    <a herf="https://gist.github.com/velopert/e0d5a027f60a7368b2bb6f9277e3f742">코드확인</a>
</details>

[코드확인](https://gist.github.com/velopert/e0d5a027f60a7368b2bb6f9277e3f742)



---

## 22. Context API 를 사용한 전역 값 관리

현재 만들고 있는 프로젝트를 보면, App 컴포넌트에서 `onToggle`, `onRemove`가 구현되어 있고, 이 함수들은 UserList 컴포넌트를 거쳐서 각 User 컴포넌트들에게 전달이 되고 있습니다.

UserList 컴포넌트는 단순 다리역할만 하고 있습니다.

만약 3~4개 이상의 컴포넌트를 거쳐 전달을 하는 일이 발생하면 구조가 복잡해질 것입니다.

이 때 Context API 와 dispatch를 이용하면 복잡한 구조를 해결할 수 있습니다.

리액트의 **Context API**를 통해 프로젝트 안에서 전역적으로 사용할 수 있는 값(값, 상태, 함수, 외부 라이브러리 인스턴스, DOM 등)을 관리할 수 있습니다.



새로운 Context를 만들어봅시다.

```javascript
const UserDispatch = React.createContext(null);
```



Context 안에는 Provieder라는 컴포넌트가 있습니다. Provider의 value를 통해 Context의 값을 정할 수 있습니다. 

```
<UserDispatch.Provider value={dispatch}>...</UserDispatch.Provider>
```



이렇게 하고나면 Provider로 감싸진 컴포넌트는 어디서든 Context의 값을 다른 곳에서 바로 조회, 사용할 수 있습니다.



App.js

```javascript
...
export const UserDispatch = React.createContext(null);

function App() {
    ...
    
    return (
        <UserDispatch.Provider value={dispatch}>
            <CreateUser username={username} email={email} onChange={onChange} onCreate={onCreate} />
            <UserList users={users} />
            <div>활성 사용자 수 : {count}</div>
        </UserDispatch.Provider>
    );
}
```



이렇게 내보내주면(export)

다른 파일에서 아래와 같이 불러와 사용할 수 있습니다.

```javascript
import { UserDispatch } from './App';
```



이제 User 컴포넌트에서 `dispatch`를 사용할 것인데, 이를 위해 `useContext`라는 hook 을 사용해서 우리가 만든 UserDispatch Context를 조회해야 합니다.

UserList.js

```javascript
import React, { useContext } from 'react';
import { UserDispatch } from './App';

const User = React.memo(function User({ user }) {
  const dispatch = useContext(UserDispatch);

  return (
    <div>
      <b
        style={{
          cursor: 'pointer',
          color: user.active ? 'green' : 'black'
        }}
        onClick={() => {
          dispatch({ type: 'TOGGLE_USER', id: user.id });
        }}
      >
        {user.username}
      </b>
      &nbsp;
      <span>({user.email})</span>
      <button
        onClick={() => {
          dispatch({ type: 'REMOVE_USER', id: user.id });
        }}
      >
        삭제
      </button>
    </div>
  );
});

function UserList({ users }) {
  return (
    <div>
      {users.map(user => (
        <User user={user} key={user.id} />
      ))}
    </div>
  );
}

export default React.memo(UserList);
```



위와 같이 하면, Context API 를 사용해서 `dispatch`를 어디서든지 조회해서 사용할 수 있어서 코드의 구조가 훨씬 깔끔해질 수 있습니다.



이로써 `useState`를 사용하는 것과 `useReducer`를 사용하는 것의 차이를 알 수 있습니다.

`useReducer`를 사용하면 `dispatch`를 Context API를 사용해서 전역적으로 사용할 수 있게 해주어 컴포넌트에게 함수를 전달해 주어야하는 상황에서 코드의 구조가 훨씬 깔끔해질 수 있습니다.

만약 깊은 곳에 위치하는 컴포넌트에게 여러 컴포넌트를 거쳐 함수를 전달해야 하는 상황이 생기면 Context API를 이용해주면 됩니다.



---

## 23. Immer, 더 쉬운 불변성 관리

리액트에서 배열이나 객체를 업데이트 할 때는 직접 수정하면 안 되고 불변성을 지켜주면서 업데이트 해주어야 합니다.



object에서 해당 key의 value값을 바로 바꾸어주는 것이 아니라,

새로운 object를 만들고 기존 object를 복사한 후 바꾸어 주어야 합니다.



배열의 경우에도 `push`, `slice` 메소드나 n번째 항목을 직접 수정하면 안 되고,

`concat`, `filter`, `map`등의 함수를 사용해야 합니다.







---

**Reference**

https://react.vlpt.us/basic/20-useReducer.html

https://react.vlpt.us/basic/21-custom-hook.html

https://react.vlpt.us/basic/22-context-dispatch.html